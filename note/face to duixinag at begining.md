# 面向对象

(我们的#include \<stdio>其实是引入printf等声明而不是引入库，系统会自动把库与我们的程序连接)

对象：什么都是对象

人类对象：人类的具体化

对象都是独立唯一的

类：具有相同属性和行为的对象统称

封装：目的在于把设计者和使用者分开，使用者不需要知道设计者是怎么实现的的

继承：对于类的关系描述。子类会继承父类的某些属性和行为，但不是全部；对于一个父类，他可以有多个子类；对于一个子类，它可以继承于多个父类

以下都是在Arduino中的使用（我先学着这玩意先，c和c++慢慢来）

#### 建立类

建立类要在所有函数外面，格式为

class a(类名称){};(一定记得要加分号)

其中可以包括public(公有成员函数)和private(私有成员函数)，公共成员函数是可以在外部调用的(除了构造函数和析构函数)，私有成员函数是不可以在外面调用操作的

#### 构造函数

在Arduino定义类对象后，马上就会引用对应的构造函数进行初始化，构造函数让类的对象后面可以加()里面填数值

构造函数前面不用加返回值数据类型说明(别写成void)，就直接写就好如Led()； （括号里面是参数）

具体写这个构造函数可以在建立类的外面，如

Led::Led(){}(最前面的是类名称,::后的是构造函数名函数)

可以同时存在多个构造函数，只要输入参数数据类型不一样就好了(进一步学习发现这就是函数重载，**重载函数的参数个数，参数类型或参数顺序三者中必须有一个不同**)，还可以通过默认形参达到很好的效果。但是不要让编译器迷糊，如让`Box();Box(int x=0);`同时出现

复制构造函数：该函数只有一个形参，即本类对象的引用，如果没有写复制构造函数(注意，只写了构造函数的不算)，系统会自动使用默认复制构造函数，效果就是把给对象中的所有数据成员复制一遍赋值给新对象。`class Box{...};Box a(...);Box b(a);`b会变成a的克隆体，数据成员的值都是一样的。(基本和Box b=a效果是一样的)

当然，还可以自己写复制构造函数:类名(类名 &对象名){}

（其实复制构造函数纯纯被名字拖累了，它的用处远远不止复制，只要是想用一个对象的数据，传一整个对象进去就会用到）、

考试经常喜欢考复制构造函数的调用次数，考点是复制构造函数会在以下情况下被自动调用:

1. 函数中的参数是对象。此时会调用复制构造函数把实参的量传递给形参，如`void f(point p0){...};`
2. 函数的返回值为对象时，获取返回值需要复制构造函数，如`point f(){...};p=f();`
3. 用一个对象去初始化另一个对象时，如`point p1=p2;`

可能混淆的不调用的情况有:

1. 直接赋值:`point p1,p2;p1=p2;`
2. 形参是引用:`point p;point f(point &p);`

建立对象时可以手动申请空间`A(类名) *p=new A;`(此方法是在堆上创建，不用new就是在栈上创建)

可以一次建立多个对象，如`A(类名) a[2]`就建立了两个对象a[0]和a[1]。

#### 析构函数

Arduino在删除执行完的函数(如Set up)(碰到后面的大括号)中的对象前，会执行改对象的析构函数，

一个类只有一个析构函数，不能重载

它的建立和编写都和构造函数一模一样，在此不赘述。

构造函数和析构函数可以没有，如果有，建立类后就要写

消亡并执行析构函数的顺序与构造函数是相反的，先构造的后消亡，后构造的先消亡。

#### 类的成员函数

写在建立类的外面（也要在后面）

其返回值的数据类型是写在类名称的前面的(也就是最前面),如：

int Led::getLedPin(){}

在外调用时格式  myLed(类的对象名).on()(类的成员函数)

如果想要在外面调用构造函数或析构函数的参数，最好在建立类中公共部分先定义一个参数，然后用这个公共的可以调用的参数来接需要的参数(被需要的函数赋值)；如果懒可以用另一种传参数的方法:Led::Led(int userLedPin) :LedPin(userLedPin)

如果想在编写公有成员函数时使用类的成员函数,可以直接写变量名，但是在别的函数中，要写成myLed.ledPin(注:==要写类对象+'.'而不是类名称+'.'==)

对象之间可以相互赋值，如果直接用`=`赋值需要调用类的构造函数

返回值是对象的函数：

```c++
class Complex{
    int I,R;
    public:
    Clock add(Clock &a)
    {
        Clock b;
        b.R=R+a.R;
        b.I=I+a.I;
        return b};
```



#### 公/私

如果没有指定成员类型，则默认为private

想要使用甚至私有成员变量可以通过一个公有成员函数实现，如要使用或更改私有....ledPin:

Led{public:...int Led::getLedPin(int userLedPin);void Led::setLedPin()} ;    int Led::getLedpin(){return ledPin;}

想用ledPin的时候就用myLed.getLedpin()就好了。而修改的实现如下:

void Led::setLedPin(int userLedPin){ledPin=userLedPin;pinMode(ledPin,OUTPUT)}

***==注:我写到这儿的时候只觉得有点不对，突然猛地一看，好像是个挺重要的东西：类的成员函数竟然可以不通过指针直接访问到类的成员变量，还可以随便改(问了老师之后发现其实并不是我想的那样一个简化操作的逻辑，而是类成员变量在类中相当于全局变量，而函数其实本来就可以不借助地址和指针等修改全局变量的值(世界观崩塌中))==***

（又发现一个问题：我在Arduino中可以随便初始化，但在visual c++中竟然不能在定义类时初始化，在查询后发现差异是版本不同导致的，在C++11标准(2015年实施)前不允许。经过询问老师后得知可以把所有的初始化都放在构造函数中来解决这个问题。）

==之所以要这么麻烦地把可以在公共部分本来一两行解决的东西花大代价放在私有部分中是因为这可以实现封装，如果不这么做，使用者可以改变设计者的程序，这是不能接受的，封装可以实现程序的稳定== 

### this指针

**1. this指针的用处:**
一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 　　例如，调用date.SetMonth(9) <===> SetMonth(&date, 9)，this帮助完成了这一转换 

**2. this指针的使用:**
一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this->n = n （不能写成n = n）。

**3. 关于this指针的一个经典回答:**
当你进入一个房子后， 　　
你可以看见桌子、椅子、地板等， 　　
但是房子你是看不到全貌了。 　　
对于一个类的实例来说， 　　
你可以看到它的成员函数、成员变量， 　　
但是实例本身呢？ 　　
this是一个指针，它时时刻刻指向你这个实例本身

**4.this指针是什么时候创建的？
this在成员函数的开始执行前构造，在成员的执行结束后清除。**

**5.我们只有获得一个对象后，才能通过对象使用this指针。**
而且即使我们知道一个对象this指针的位置，也不能直接使用，因为this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。



### 类的初始化列表

1. 格式`类名::类名(对象成员所需的形参,其他数据成员形参):对象1（参数）...{}`

2. 注意，该列表的初始化顺序是类中的声明顺序，与列表中的顺序无关，如:

   ```c++
   class A{
       int x;
       int y;
   };
   A::A():y(1),x(y){}
   ```

   这样A的y值一定是1，但是x值是任意的。因为它按照类中的顺序先用y初始化x，由于此时y还没有被赋值，x最后的结果就可能是任意值

3. 





----

### 对象的高级应用

#### 类的组合

将简单对象作为复杂对象的数据成员。

其特殊主要体现在：

1. 构造函数中对象成员的初始化要使用初始化列表`类名::类名(对象成员所需的形参,其他数据成员形参):对象1（参数）...{}`，如包含两个点类成员的线类函数(省略了类内声明)`Line::Line (Point ps,Point pe,int s)：p1(ps),p2(pe)`在类内我们只能使用对象p1,p2，因为整个逻辑是ps,pe(括号中的对象)只是提供数据的，而后面的p1(ps)的意思是自动调用复制构造函数构造出一个生存期和作用域都在Line类中的新对象。而且只能用这种类型初始化对象，不能进去类里面以后设2一个对象然后把某个对象赋值给它。
2. 对象成员的私有成员不是组合对象的成员。如在Line类中不能直接访问Point类中的私有对象，如x,y等，而是要通过Point的公有成员函数来实现访问
3. 构造函数和析构函数起作用的顺序。构造函数是先调用对象函数所属类的构造函数后调用本类的，而析构函数则是先调用本类的析构函数后调用对象成员所属类的析构函数的。

#### 友元

一种打破封装的隐藏机制。

通过在类A中声明类B或函数f为友元可以让B或f直接使用类A的私有成员。`friend 友元函数名或类名，如friend void set();或friend class Line`记得声明友元时把函数的返回类型，参数和类的class前缀带上。

注意友元是单向的且不可传递的，在类A中声明类B为友元只能让类B访问类A的私有成员而不能反过来。

#### 运算符重载

定义运算符的新功能，一般把运算符重载为类的成员函数或重载为友元函数。其实质仍然是函数调用。

`返回值类型类名::operator 重载的运算符(形参表)`如重载‘+’使它能算复数类。

```c++
class Complex{
    ....
public:....
	Complex operator+(Complex c);        
}
Complex Complex::operator+(Complex c){
    Complex temp;
    temp.Real=Real+c.Real;
    temp.Image=Image+c.Image;
    return temp;
}
int main(){
    Comolex c1(3.0,1.0),c2(1.0,4.0),c3;
    c3=c1+c2;
    return 0;
}
```

为什么说重载它实际上还是函数调用呢，其实上面的复数类相加相当于做了一次c3=c1.operator+(c2)，我们重载为类的成员函数时，由于类的成员函数在外调用格式是对象名.成员函数(形参)，所以这种重载的形参表中的参数个数是原操作数-1,另一个操作数就是在运算符前的数；而重载为类的友元函数其参数表中的参数个数就等于原操作数

如果是重载为友元函数应该是:

```c++
class Complex{
    ....
public:....
	friend Complex operator+(Complex c1,Complex c2);        
}
Complex operator+(Complex c1,Complex c2){
    double tempReal,tempImage;
    tempReal=c1.Real+c2.Real;
    tempImage=c1.Image+c2.Image;
    return Complex(tempReal,tempImage);
}
int main(){
    Comolex c1(3.0,1.0),c2(1.0,4.0),c3;
    c3=c1+c2;
    return 0;
}
```



但是重载有限制：

* 只能重载除了"."".*""``"::""?:""sizeof"之外的运算符
* 只能重载c++原有的运算符，不能造新的
* 不能改变原运算符的优先级和结合性
* 不能改变原计算符的操作数个数
* 重载的运算符的操作数至少有一个应该是自定义类型

#### 类的静态成员

类的友元用于不同类对象之间的数据共享，而类的静态成员则用于同一类中不同对象的数据共享。

类的静态成员属于整个类，无论创建几个对象，类的静态成员的空间只会被分配一次，所有对象都可以共享这一空间。

1. 静态数据成员：它只能在类外定义或初始化，在类内只能声明它，在类外定义或初始化格式:`数据类型 类名::静态数据成员名(=值);`

   ```c++
   class Bookcard{
   ...
   static int sum；
   public:..
   };
   int Bookcard::sum(=5045);//书的总量
   ```

   注意:在类中声明时要加上static，但在类外定义或初始化时不能加

   在类外访问静态数据成员可以通过对象名.静态数据成员名或类名::静态数据成员名

   静态成员函数：想要在对象创建前操作静态数据成员就只能使用静态成员函数。但由于它属于整个类而不是某个对象所以它只能访问类中其他静态成员。

   ```c++
   class Bookcard{
   	...static int sum;
   public:...
   	static int init(int t){sum=t};        
       static int getsum();
   };
   int Bookcard::sum;
   int Bookcard::getsum(){return sum;}
   ```

   静态成员函数可以在类内写函数体



#### 常引用，常对象和常函数

常引用：格式`const 类型& 引用名;如const int& b=a;(b是a的别名);(前面的&可以接在b前面)(区别于int &b=a;)`

这样只能通过修改a(被引用的"本体")才能同时修改a和b，给b赋值会显示错误

常对象:其数据成员在整个定义域内都不能被修改

==因此常对象的数据成员为常量且必须有初值==

格式`类名 const 对象名[参数表];或const 类名 [参数表]`

常数据成员：只能通过构造函数初始化，后面就动不的数据成员，如`class A{public:...private:const int a;};`a就是常数据成员(这里有别于常数，可以不在这初始化，而是在对象被创建时由它的构造函数初始化)

常成员函数:不能修改数据成员的函数(只读函数，用于加强稳定性)

格式:`返回类型 成员函数名(参数表) const,如int function(int x) const`(注意const是在后面的，而且跟函数是一起的，在函数声明和定义时都需要加上，调用时不需要)

特点:

1. 不能更新类的成员变量

2. 不能调用该类中没有被const修饰的成员函数(只能调用常成员函数)

3. 可以被其他成员函数调用

4. **常对象只能调用常成员函数，不能调用其他的成员函数**

5. const可以区分重载函数，对于又有有const的成员函数又有不带const的成员函数的情况，一般对象会优先调用不带const的成员函数,如

   ```c++
   class A{
   int a,b;
   public:
   	A(int x,int y){a=x;b=y;}
   int printa() const{
   	return a+1;
   }
   int printa(){
   	return a;
   }
   void printtt(){
   	cout<<printa();
   }
   };
   int main(){
   	A b(0,0);
   	b.printtt();}
   ```

   结果是0

   而对于常对象，它只能调用常成员函数，不存在分不清两个函数的情况

6. 

### h和cpp

在存放程序的文件夹中创建一个.h文件和一个.cpp文件

把类的声明(告诉系统有哪些函数，变量等但不告诉它怎么实现)放在.h文件里；类的其他内容(成员函数等)放在.cpp文件中。

在.h(头文件)中需要#include<Arduino.h>,在.cpp文件中需要#include"led(头文件名).h"（在系统中，包括第三方库中时，可以用<>引用，对于和程序存放在一个文件夹的.h和.cpp要用""引用）(逻辑上应该是先有头文件才有.cpp，所以.cpp要include头文件不难理解)

为了避免重复编译，我们会在头文件加上宏定义最前面加上

#ifndef  _ LED(大写头文件名)_H _

#define_LED_H_(中间不能有空格，纯粹因为md语法问题)

在最后加上#endif

此段代码的逻辑是为避免重复编译，让这段编译代码仅在头文件中编译，我们告诉系统在#ifndef _LED _H _(if not define ...)到#endif之间的内容只在没有define这个头文件时编译，然后我们就在下面写上#define _LED _H _也就是这里就编译头文件了，于是头文件的程序只会在这里编译，避免了重复编译

注:对于Arduino对应的ino后缀文件，它必须存放在同名文件夹中才能打开，我们可以把.h.，cpp文件和它放在同一个文件夹中，这样只要打开ino文件，.h和.cpp都会自动打开，也可以放在第三方库中，这样这些文件不会打开，但是只要用<>引用就可以使用其中的东西

## 继承与多态

继承类型有public,private和protected

建立子类的格式:class PwmLed (子类名称): public(继承类型) Led(父类名称){};

无论哪种继承，都是继承父类的public和protected，区别只在于这些继承过来的东西会变成子类的什么封装类型

public类继承会使父类中的public都成为子类的public，protected也不变

protected类继承会让public和protected都变成protected

private类继承会让他们都变成private

继承后记得在子类的构造函数中初始化的继承的父类，不然会自动调用默认构造函数或无参函数对父类进行初始化



### 类型兼容

基类能做的，派生类也能做。因此，在需要基类对象地址时，可以填一个派生类对象地址进去，这样，公有派生类对象可以作为基类对象使用，==针对基类的代码也可以操作派生类==。但要注意，若此时基类和派生类有同名函数，则会调用基类的函数而不是派生类的，这就是类型兼容。

（不能在要填一个派生类对象时填一个基类对象进去，但可以在要填一个派生类对象地址时填一个基类对象地址进去）

```c++
class A{public:void diplay(){cout<<"A print"<<endl;}};
class B{public:void diplay(){cout<<"B print"<<endl;}};
void fun(A *p){p->display;}
int main(){A a;B b;
          fun(&a);
          fun(&b);
          return 0;}
```

输出结果为两个A print，因为fun函数要的是基类，虽然可以填派生类进去，但是需要调用对应函数时还是会从基类中调用。

(如果这里不只是cout而是直接操作这个对象，也是合理的，即操作基类的函数可以操作派生类)

### 同名函数问题

根本逻辑在于继承的机制是copy父类的一部分进子类，但是不会和子类的其他部分弄混，而是有单独的标记，把这些叫做父类域；；子类本来就有的叫做子类域

1. 隐藏：如果子类中函数有和它继承父类得到的函数同名的，将不会调用父类而是用自己类中的定义(先找子类域再找父类域)

   (事实上不止于此，一旦子类中出现同名成员函数，父类中所有的同名函数都用不了了，即使参数不同也不行，不会重载)(找完子类域就认为没有了，不会去找父类域)

2. 覆盖(覆写):父类中函数用了关键字virtual声明函数，称其为虚函数，子类中对它的使用可以把它理解为在父类中的函数声明(实际上它真的可以只声明而不说函数是怎么实现的)，我们需要(或着说可以)在子类中重新写它的实现(记得返回类型，参数表都要一样，不然认为是重载)(这一过程相当于把父类中的函数"覆盖"掉了(但是其实还存在，依然可以通过`子类对象.父类名::函数名`调用这个虚函数))(==virtual这个关键词只用写一次，如果是类内声明类外定义那么只要写在类内声明中，而继承中这个虚函数属性也会自动继承到子类中==)

   一定要记住：==虚函数的提出，是为了实现多态。==也就是说，虚函数的目的是为了，在用父类指针指向不同的子类对象时，调用虚函数，调用的是对应子类对象的成员函数，即可以自动识别具体子类对象。

   ```c++
   class Father
   {
   public:
       virtual void ff1() {cout<<"father ff1"<<endl;}
   };
   
   class Childer_1:public Father
   {
   public:
       void ff1() {cout<<"childer_1 ff1 "<<endl;}
   };
   class Childer_2:public Father
   {
   public:
       void ff1() {cout<<"childer_2 ff1"<<endl; }
   };
   
   int main()
   {
       Father* fp;
   
       Childer_1 ch1;
       fp = &ch1;
       fp->ff1();
   
       Childer_2 ch2;
       fp = &ch2;
       fp->ff1();
   
       return 0;
   }
   ```

   使用虚函数，都是父类指针的形式，pf->f11() 。例子中的24行和28行，相同的代码，因为fp的指向不同对象，所以调用不同对象的虚函数。但从代码上看，fp是一个Father类的指针，但调用的是子类成员函数，就好像父类的成员被覆盖了一样。这就是覆盖一词的来源。

    

   引申：纯虚函数是指没写实现的虚函数，他们不可能实现，需要在每个子类中覆写一遍。它的用处不在于使用，而在于规范:在父类中加上纯虚函数相当于提供一个接口，所有子类都要写一个同名函数，不然就报错，以这种方式可以规范子类的定义，实现多态性。

   在基类中实现纯虚函数的方法是在函数原型后加 =0:如`virtual void funtion1()=0`

   ==一旦在类中定义了纯虚函数，这个类就会成为抽象类，抽象类不可被实例化==，即抽象类不能有对象，但是可以有指针或引用(实际上抽象类都用不了，之所以允许它的地址有关的东西存在只是因为有类型兼容，抽象类的抽象指针可以给子类实例对象留出端口)，如对抽象类A，`A a;(或f(A a);)`是非法的，`f(A &a);`却是合法的

3. 重载:额外记得子类和父类之间没有重载的说法就可以了。



### 函数/类模板

想swap这种函数，如果交换int,char....各种类型都要定义一个函数就太麻烦了，所以有了模板

```c++
template <class 类型参数1, class类型参数2, ...>
返回值类型  模板名(形参表)
{
    函数体
}
(class可用typename代替，如template <typename 类型参数1, typename 类型参数2, ...>)
```

上述swap函数就是

```c++
template <class T>
void Swap(T & x, T & y)
{
    T tmp = x;
    x = y;
    y = tmp;
}

```

后来想确定为某几中数据类型可以用\<int>这种方式

在函数中定义一个类对象很像定义一个参数，它也有作用域，要全局作用就写在最外面，格式如下：

a(类名字) b(类对象名字)；(记得Servo myservo吗，就是一个建立类对象的过程)

## 入门易忘

1. 只要不是类里的成员函数，其他地方使用类中公共部分的变量，函数等都必须在前面加上类对象名称+'.'
2. 每次改变引脚编号都要在后面马上加上pinMode(新引脚编号,HIGH/LOWPUT)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    

 
