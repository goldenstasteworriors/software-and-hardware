@[toc](freertos)

裸机中要执行两个任务要先完成a再完成b，但是freertos中可以把a和b划分成多个小步骤然后每次一个步骤来执行；在裸机中完成会互相影响的操作(延时实现灯的)

要实现freertos要理解cpu，也有厂商用内存块开发不过少，大部分还是用的arm内核

freertos是实时操作系统，它只实现了基本的内核功能，在产品只需要多任务时大多使用freertos，他不涉及文件系统等功能；后面可以再学RT_Thread这种国产操作系统







## 堆栈

堆：空闲的内存，可供调用

栈：无名英雄

![image-20231003094201877](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231003094201877.png)

如在以上代码中，在调用函数前需要先将下一行语句保存在LR(LinkRegister)(一个寄存器)中，不然调用完都不知道去哪。但是在这里，main调用a_fun,a_fun调用b_fun，导致LR会被覆盖，解决方式就是在要存下一个LR时(这里是a_fun中)(在a_fun内部)将的LR入栈(具体可以看汇编)

在C的函数入口处会先：

1. 划分栈(LR....,局部变量)
2. LR等寄存器存入转
3. 执行代码

实际来看汇编

![image-20231003100336694](C:\Users\asus\OneDrive/桌面/NEW_MY/freertos_study/freertos/image-20231003100336694.png)

设置SP即在内存中设置栈；BL main会 1. LR=返回地址 2. 执行main    ；在main函数中，会首先划出自己的栈，比如划到SP-N(栈是从栈顶算下来的)，在这些栈中保存LR等寄存器和局部变量；后面函数也是一样的，比如a之前也会 1. LR=返回地址 2. 执行a_fun

而在函数中也需要栈的参与，比如a+=size这一句，首先a就是存在栈中的，要执行这句话实际上是算出a+size结果后填入a的地址

栈空间是从高地址向下增长的，这点务必记住





编程规范：

![image-20231003215128248](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231003215128248.png)

![image-20231003215143692](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231003215143692.png)

函数名的前缀有2部分：返回值类型、在哪个文件定义。  

![image-20231003215200923](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231003215200923.png)



### 第一个例程

删掉官方例程中不需要的；增加串口功能

使用source insight阅读和修改代码



#### 创建任务

使用动态内存创建任务

![image-20231218211818156](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231218211818156.png)

最后这个参数，即任务句柄就是TCB的指针，是事先定义然后在这个函数里才与任务联系起来的，后续要控制任务都需要这个指针；==优先级越小，值越小==；pvParameters是要传进任务里的参数：如果创建成功会返回pdpass



使用静态内存创建任务（需要自己给出空的内存块当栈(适合内存紧张的程序)）

![image-20231218213409926](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231218213409926.png)

注意这个静态创建，他没有要填任务句柄是因为他自己返回的就是它的任务句柄，可以来个变量接一下

删除任务：`vTaskDelete(TaskHandler*)`(要删自己则参数填NULL)

任务进一步实现:

高优先级任务先执行，同优先级交替执行(目前调度方式)；用同一个函数(xTaskCreate的第一个参数相同)可以创建多个任务(传入参数不同)

关于内存malloc和free：

要malloc时，先在头部存一个结构体，存放长度等信息，然后再从地址开始处分配；同理，在free时也要先从前面的结构体中拿到长度才能free

在freertos中一定要仔细考虑栈空间问题，因为栈从高地址向下增长，如果任务中实际用到的空间比报的还多就会直接操作前面的任务产生不可控的位置影响





## 任务机制

可以认为是rtos嘎嘎中断，中断间隔为tick(系统定时器间隔，可以配置)，定时器过了几个tick存在变量tickcount里， 执行的中断回调函数就是判断是否更换任务。我们可以指定每个任务运行的时间(必须是几个tick)。

一共有四种状态:运行状态(running),准备状态(ready),暂停状态(suspended),阻塞状态(blocked)。前两个很好理解，后两个的区别就是阻塞状态是在等待某些事情发生(就像等待标志位)，暂停状态是主动或被动休息(其实暂停状态的suspended也可以理解为挂起，这样就好理解多了)，转换图如下：![image-20231004210007475](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231004210007475.png)

任务的管理方式是链表，当某个任务要执行时就会从链表里拿出来执行

注意延时函数的作用都是进入挂起状态而不是在任务里延时。

vTaskDelay(t)延迟的时间***delta***t是确定的,vTaskDelay(t1,t2)确定的是会dealy到t1+t2时间点

用vTaskDelay是要保证延时时间一致；使用vTaskDelayUntil是保证运行周期一致



#### 空闲任务

空闲任务(Idle任务)是`	vTaskStartScheduler()`这个函数创建好的，CPU空闲时执行的任务，它的优先级为0，它只会处于运行和就绪两个状，永远不会不会阻塞

空闲任务的作用包括清理内存(vTaskDelete留下的)等，此外，我们还可以用它执行一些低优先级的后台的需要连续执行的函数

清理内存时自带的功能，我们想要它执行函数就得使用到钩子函数`Idle Task Hook Functions()`了，相当于空闲任务的回调(虽然这么说完全不准确) ，他可以：

1. 执行一些低优先级的、后台的、需要连续执行的函数
2. 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。
3. 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了

但它也有限制：

1. 不能导致空闲任务进入阻塞状态、暂停状态
2. 如果你会使用 vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存



## 任务调度算法：

主要根据几个关键问题定自己的任务调度算法：

1. 高优先级务能否抢占低优先级任务
2. 如果可以抢占，同优先级任务是否轮转执行
3. 如果可以抢占而且轮转执行，空闲任务是否低人一等

任务调度算法的选取主要是靠FreeRtosConfig里的几个宏定义的取值实现的，具体来说：

![image-20231004233547355](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231004233547355-17114566671511.png)

![image-20231004233611604](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231004233611604.png)



### 同步互斥与通信

同步：即通过协调通信，实现信息的同步，如告知a任务某资源的使用情况等

互斥：即某临界资源只能由一个任务使用

要实现任务间通信很容易，用全局变量就可以实现

```c
int flag=1;
void Task1function(void * param)
{if(flag)
    {
        flag=0;printf("1");flag=1;
    }
}
void Task1function(void * param)
{if(flag)
    {
        flag=0;printf("2");flag=1;
    }
}
```

但其实还需要满足两个条件：

1. 正确性
2. 效率

这两点全局变量都满足不了：

1. 会有bug：有可能会在任务1/2运行到flag=0与flag=1时切换任务，这样这两个任务永远都被卡死了
2. 特别慢：相当于一个任务在跑的时候另一个任务虽然没事干也要抢cpu来看任务是否完成，拖慢正在跑的任务

因此，要求：

1. 方法要安全
2. 等待的任务要进入阻塞模式(阻塞模式不占cpu而是等待被唤醒)

之前一直很疑惑关于阻塞的问题，但后来又看了下例程就搞明白了：阻塞状态不是用if来判断的(我本来想的阻塞状态是类似if(xQueueReceive)这样的)，其实重点不是if，直接用会阻塞的函数就可以了，==阻塞状态是靠真的走到后被堵住来实现的==，即直接把xQueueReceive()放在任务里，执行到这里之后发现队列里没数据，就进入了阻塞状态，直到有信息进来，任务就会进入就绪状态

实现同步，互斥的内核方法有：任务通知，队列，事件组，信号量，互斥量等

### 队列(queue)

使用队列实现同步互斥：

1. 同步：QueueReceive()阻塞不用的任务
2. 互斥：只有一个任务能得到队列上的数据

![image-20231010122634847](C:\Users\asus\OneDrive\桌面\叶康杰-RM2024狼牙招新嵌软\image-20231010122634847.png)

相当于所有任务都可以是生产者和消费者，但一个数据只能被一个任务接收 

(被傻逼错误卡住了：队列要是被加进了队列集就不能直接读了)

##### 相关函数(顺便一提，几乎每个函数都有中断形式，就是在后面加上FromISR，区别就是这个函数可以在中断中使用，不会阻塞)

详见API英文参考手册，那里贼全，这里就不写了

对了别忘了QueueSend和Receive里都是传指针的，最后Receive相当于你把指针给它，他直接写在这个指针对应的变量里了



### 信号量(semaphore)

和队列类似，不同点是信号量不存储也不传递数据，只传递结构体本身，其实就是只传递一个数，当作一个信号的作用

要注意的是如果信号量已达最大值，再give会返回错误而不是我本来想的无作用

还有一个要注意的点是在使用信号量（尤其是二进制信号量时)很容易出现发送很多次但是只收到一次，这时可以选择在接收时一次接收完数据

可以用先take再give的方式实现互斥



### 互斥量(mutex)

很多临界资源需要保护正是因为他们的操作是非原子化的，即他们的操作都可以被打断，那这根据之前数据库的知识显然会导致无数的问题，所以如果条件允许这种时候最好使用可重入的函数。

"可重入的函数"是指：多个任务同时调用它、任务和中断同时调用它，函数的运行也是安全的。可重入的函数也被称为"线程安全"(thread safe)。每个任务都维持自己的栈、自己的CPU寄存器，如果一个函数只使用局部变量，那么它就是线程安全的。函数中一旦使用了全局变量、静态变量、其他外设，它就不是"可重入的"，如果改函数正在被调用，就必须阻止其他任务、中断再次调用它。(所以全局变量不靠谱)。上述问题的解决方法就是上锁。

互斥量相比信号量和队列的好处是(按道理来说)只能由上锁人开锁,虽然freertos并没有从代码上保证这一核心功能，但他还是因为这个用途有一些其他的性质

==by the way,freertos里对于锁没有解锁者只能是上锁者之类的保护机制，主打一个全靠自觉==



互斥量其实是特殊的二进制信号量(甚至用的还是信号量的句柄)(ps:要用互斥量记得有个量要define)，主要区别(互斥量的特点)有：

1. 互斥量初始值是1，不用先Give一次；
2. 刚开始配置后被take到0的互斥量只能由take的这个任务来give，其他的任务会give不成功
3. 信号量有优先级反转的问题:高优先级的任务会由于开不了低优先级任务的锁而被阻塞，但低优先级的任务因为抢不过中优先级的任务而一直无法运行，四舍五入就相当于中优先级的任务把高优先级的任务给卡死了，这还得了？所以就有了互斥量的优先级继承机制:如果高优先级(比如priority=3)的任务因为低优先级任务(1)的锁而没法运行，低优先级任务就会继承高优先级任务的优先级，直接抢占中优先级(2)运行完，把锁开了，这样高优先级任务就保住了自己的地位(手动狗头)
4. 有种特殊的互斥量:递归锁。递归锁的好处在于它在代码上实现了哪个任务上锁就只能由哪个任务解锁；通过允许一个任务多次开锁避免了死锁(开锁机制类似与可以开锁到负数次，比如开了两次锁，就得再锁两次才到原来的状态，别的任务才可以锁)



### 事件组

事件组的作用也是通知，它的特殊地位来自于前面的老哥都没办法同时整多个事件。

![image-20231013195441184](C:\Users\asus\OneDrive\桌面\叶康杰-RM2024狼牙招新嵌软\image-20231013195441184.png)

这东西看起来挺玄乎，其实简单的一比，就是用一个位是0还是1来判断事件是否完成。其中，前八位不能使用。

其它的配套函数实现的功能都是基于前面这句话的，setbits用来通知什么时间做完了，waitbits用来阻塞，还有同步点，用来同时阻塞多个任务(完成这些事件后这些被阻塞的点会同时被解开)



### 任务通知

任务通知和之前实现同步互斥的方法不一样的是它不用再创建一个新的数据结构，而是用任务中自带的结构体传递信息，这样既不用浪费内存效率还嘎嘎高

创建任务时就会创建一个TCB结构体，里面有两项:ulNotifiedValue(通知数据)和ucNotifyState(通知状态),通知状态有三种取值:任务没有等待通知，任务在等待通知和任务已经接收到通知正在处理。

任务通知不是之前的多对多，它是多对一的(指定任务接收)

任务通知会把本来正在阻塞状态的任务变成就绪态

任务通知有两套函数:简单版和专业版。简单版就是拿来当信息量用的，专业版可以干更多事情。专业版函数参数挺复杂的，要用的时候还是建议看下API手册。

任务通知其实就是其它方法的轻量式单任务方案，如轻量式信息量，轻量式队列，甚至是轻量式事件组



### 软件定时器

和一般的定时器中断差不多，整完了就回调

比较不同的是软件定时器并不是在tick中断里执行回调函数的，由于要保证实时性，freertos整了一个守护任务(RTOS Damemon Task)，专门用来执行这些函数(因此无论在哪个任务启动的定时器，都是由守护任务来执行回调的)。要使用这个任务需要设置一个宏，这个任务的优先级也可以自己指定(也是通过宏来设置)。

我们自己编写的任务函数要使用定时器时，是通过"定时器命令队列"(timer command queue)和守护任务交互，因此，所有的函数都有可能失败(命令队列满)，所以，像start函数这些的tick to wait参数都是如果队列已满的等待超时时间

定时器只有两个状态:运行状态(正在等待超时)和冬眠状态

![image-20231014124527928](C:\Users\asus\OneDrive\桌面\叶康杰-RM2024狼牙招新嵌软\image-20231014124527928.png)

注意reset之类的都会把定时器变为running状态

这样定时器能实现一个很简单很有效也很好玩的按键消抖:在中断后不直接执行中断函数，而是先开个计时器，延时个20ms，期间如果中断再发生就直接Reset，等到延时完了再执行回调，这样不同于直接在中断里延时的野蛮操作，可以快速出中断。



### 中断管理

freertos里的中断是硬件相关的，优先级天生高于所有任务(认为只与软件相关)，因此，给它整了一堆的机制。

首先是我们都知道的中断的特有函数FromISR，这个函数首先是不能阻塞(中断都不能阻塞)，然后是会有个**xHigherPriorityTaskWoken**参数，这个参数还是挺特别的，它是用来传信号出去的，就是个标记位。使用前要先把它设置为pdFALSE。这个参数用来标记是否有更高优先级的任务因为中断就绪，如果有，就会返回pdTRUE，就要由中断来切换任务。而在ISR中为了保证效率，会统一执行完后再跳转任务(一个是因为中断不可能被任务抢占，所以在中断中切换任务没有意义；二个是因为在中断中可能多次使用了...FromISR函数，为了效率考虑就只需要在ISR结束返回的时候进行任务切换(具体是使用portYIELD_FROM_ISR( xHigherPriorityTaskWoken )函数))。

还有就是为了实现推出中断尽可能快，一般在ISR函数中只会执行必要的操作(清理中断标记位等)，然后赶紧唤醒一个任务用来处理其它的事情，该任务被称为中断的延迟处理任务(deferred processing task)



### 资源管理

主要使用到的方法就俩:屏蔽中断和暂停调度器，分别对应这干中断和停任务(需要注意的是由于任务调度就是在中断中完成的，所以屏蔽中断一般也会无法使用任务调度)。



==屏蔽中断==原理就是在中断向量中有个宏开关，我们可以设置这个宏开关对应的优先级：

(在任务中屏蔽中断)在 `taskENTER_CRITICA()/taskEXIT_CRITICAL() `之间：

低优先级的中断被屏蔽了：优先级低于、等于 `configMAX_SYSCALL_INTERRUPT_PRIORITY`

高优先级的中断可以产生：优先级高于 `configMAX_SYSCALL_INTERRUPT_PRIORITY`

但是，这些中断ISR里，不允许使用FreeRTOS的API函数;且这两段代码之间，不会有任务调度产生

这套 `taskENTER_CRITICA()/taskEXIT_CRITICAL()` 宏，是可以递归使用的，它的内部会记录嵌套的深度，只有嵌套深度变为0时，调用` taskEXIT_CRITICAL() `才会重新使能中断

同样，在中断中有另一套屏蔽中断的函数，不同点在于要额外用个变量记录下当前中断状态。



暂停调度器:所有任务暂停调度

```c
vTaskSuspendScheduler();
/* 访问临界资源 */
xTaskResumeScheduler();
```

同样，可以暂停调度



### 调试方法

1. 串口调试
2. 断言(assert)。c中断言是`assert(expression)`，就是判断这个expression是不是真的，不是真的直接崩。在freertos中用的是`configASSERT()`(这是个宏不是函数)，可以通过更改宏实现想实现的功能
3. 跟踪(trace)。本来是空的宏，可以自己编写来实现功能。都是trace开头的宏，作用就是它的名字
4. 钩子(hook).堆溢出和栈溢出会有判断的钩子函数。栈溢出的判断会稍微复杂些，有个宏开关可以选择1，2两种判断模式，一种是直接检测TCB里的数据，但这个会由于更新不及时而不准；另一种是填满0xA5然后检测栈底是不是都是0xA5来判断，慢点但是推荐使用



### 优化

1. 栈使用情况：在创建任务时分配栈后填入固定数值(0xA5)后可以使用`uxTaskGetStackHighWaterMark(TaskHandle_t xTask)`来查看栈的高水位，即还有多少空余的栈空间(原理是从下往上判断0xA5).对了，由于栈是32bit所以一层放了四个字节，返回的也是层数，即空闲字节数/4。一般来说保证几十字节的空栈即可，可以凭此改下创建任务时给的栈空间
2. CPU空闲时刻



### 相关bug

1. no 'read' permission：队列之类句柄的没赋值就使用了
