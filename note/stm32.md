### 寄存器编程

要使用外设，需要寻址，地址见参考手册(存储器映像)，寄存器就是外设的地址。(SRAM和FLASH后面说)

![image-20221115105245451](C:\Users\86180\Desktop\my\note\image-20221115105245451.png)

可见地址是以八位16进制的数表示的，一位16进制的数对应4位，故一共对应32位，也就是4个字节，所以在c中可以用int型指针来表示

所以用`volatile unsigned int *pointer`来表示一个寄存器的指针，volatile是为了避免编译器优化我们的代码

给指针初始化一个外设的地址可以`volatile unsigned int *pointer=(unsigned int*)0x40028000`(注意指针是个数据类型，要将数赋给指针需要强制类型转换)

然后用`*pointer`即可修改寄存器

一般不会这样用变量，直接用宏`#define pointer (volatile unsigned int *)0x40028000` 后面的用法是一样的(宏定义记得加上volatile)

 

### GPIO

​	GPIO是通用输入输出端口的简称，就是STM32可控制的引脚。我们用它和外部设备连接起来，通过控制GPIO引脚的电平从而实现对外部设备的控制

​	**STM32 芯片的 GPIO 被分成很多组，每组有 16 个引脚**，不是所有的引脚都是GPIO，还有电源引脚，复用引脚等，但一般有大部分引脚都是GPIO，所有的GPIO引脚都有基本的输入输出功能。

![QQ图片20221009111609](C:\Users\86180\Desktop\my\note\QQ图片20221009111609-16684822971381.png)

![QQ图片20221009113450](C:\Users\86180\Desktop\my\note\QQ图片20221009113450-16684822971383.png)

1. 中两个保护二极管可以在电流过高或过低时保护GPIO

1. GPIO的模式有八种

   ![image-20221203182450437](C:\Users\86180\Desktop\my\note\image-20221203182450437.png)

   1. 1. 两种输出模式![QQ图片20221009111350](C:\Users\86180\Desktop\my\note\QQ图片20221009111350-16684822971382.png)

   ​	左边是推挽，若输出高（低）电平则上（下）管导通，则会将out端口电平与正极（地）	相接，从而输出高（低）电平（优点：高电平与电源挂钩，驱动能力较强）

   ​	右边是开漏，若输出高电平，则下管截止，用该结构是无法直接输出高电平的，所以我们通常接一个上拉电阻从而使他有默认高电平的状态；若输出低电平则和推挽一样（优点在于可以弄线与的结构，使单个设备占据一条主线，一个输出低电平整条线都是低电平）

   2. 复用推挽，开漏没整明白，后面补

   3. 上下拉输入在arduino笔记中，不赘述

   4. 模拟输入：**主要为片上外设ADC而配置，从外部读取模拟信号**

      **测试信号未经过采样前，均是时间和幅值均是连续的信号称为模拟信号，例如连续变化的电压，电流，温度等等**(我的大课笔记的理解有点问题，以此为准)

      作为对比：**模拟信号经等间隔“采样”及幅值量化以后，时间和幅值均是不连续的（离散）的信号,例如0 /1**

      ![image-20221203182815133](C:\Users\86180\Desktop\my\note\image-20221203182815133.png)

      原理就是直接不采样通到芯片的ADC里

      

1. 肖特基触发器具有滤波的作用，就是让通过的电平输出稳定的高低电平。



### 总线架构

![image-20221127000520933](C:\Users\86180\Desktop\my\note\image-20221127000520933.png)



![image-20221126233001477](C:\Users\86180\Desktop\my\note\image-20221126233001477.png)

1. FLASH:闪存存储器，我们编写好的程序就放在这里，内核通过ICode总线来取里面的指令
2. SRAM:程序的变量，堆栈等都基于它。内核通过DCode来访问它

利用总线架构，我们可以将不同外设分开，分别控制他们使能与否。控制外设使能与否就是控制它们的时钟

### 软件编写步骤

1. 使能GPIO的外设时钟(查外设时钟的使能基地址和要设置的具体外设对应的偏移地址，要设置的就是这两个地址相加的地址)(注意区分外设的地址和时钟的地址，前者要找对应GPIO端口对应的地址+GPIO寄存器对应偏移，后者要找复位与时钟控制的地址+RCC寄存器的偏移地址)(注意16进制地址的八个数字之间不能有空格，从手册上复制下来是有空格的，记得删掉)

2. 通过查阅参考手册的GPIO章节知道要配置为什么模式。通过端口配置表展示的寄存器进行配置![image-20221126234948237](C:\Users\86180\Desktop\my\note\image-20221126234948237.png)

   

   ![image-20221126234829514](C:\Users\86180\Desktop\my\note\image-20221126234829514.png)

   ![image-20221203011555879](C:\Users\86180\Desktop\my\note\image-20221203011555879.png)

   (上面是CNF下面是MODE别找错)

   要改那个CNF和MODE要看咱接的是哪个端口，如接PB0,就改CNF0和MODE0

   输出模式位的速度是GPIO电平变化的速度

   寄存器是32位的，一个端口占2位，共有16个端口；一个MODE端口一个CNF端口叫做一组寄存器，一共有八组寄存器。

   对一个位的设置是让他输出一个高电平，清除是一个低电平

   ODR就是你输入1对应引脚就输出高电平，输入0就输出低电平

3. 

  ### 第一个程序需要注意的

4. 正常写c语言IDE会为我们设置好堆栈，但嵌软中需要我们自己配置运行环境，可以通过了两个途径配置：
   1. 运行环境管理工具

      ![image-20221126231854590](C:\Users\86180\Desktop\my\note\image-20221126231854590.png)

   2. 从我们的库包中添加

   

### c语言的位运算

位运算都算的是二进制形式

1. 按位与(&):都是1结果就是1，否则为0
2. 按位或(|):都是0则结果是0,否则为1
3. 按位异或(^):如果两个数字不同，则**结果为1，否则是0**(别搞反了)(一个数异或其本身结果是0，一个数异或0结果是它本身)
4. 按位取反(~):01互换
5. 左移(<<):向左移指定位数，溢出位数丢弃，空余位数用0补充(相当于乘以2的指定次幂)
6. 右移(>>):向右移指定位数，溢出位数丢弃，空余位数用0补充（相当于除以2的制定次幂(余数丢弃)）

按位与，按位或，按位异或是+满足交换律和结合律

只想改一位(如第三位)可以GPIOB_CLK(32位的寄存器)|=(1<<3);

一次想改多位只需要把1换成想改成的二进制对应的10进制数就好了，如想把后四位改成

清空数据:`GPIO_CRL&=~(0xf<<(4*0));`例中是一次操作16位的情况下清空低4位，如果想清空5678可以把0变成1，想清空n位可以把4变成n

#### 注

别忘了是有0位的





GPIO操控电平源码：

```c++
#define GPIOB_CLK (*(volatile unsigned int *)(0x40021000+0x18))
#define GPIOB_CRL (*(volatile unsigned int *)(0X40010C00+0x00))
#define GPIOB_ODR (*(volatile unsigned int *)(0X40010C00+0x0C))
int main(void)
{
	GPIOB_CLK |=(1<<3);
	GPIOB_CRL &=~(0xf<<(4*0));
	GPIOB_CRL |=(2<<0);
	GPIOB_ODR &=~(0x1<<(1*0));
	GPIOB_ODR |=(1<<0);
}
```



(截频快捷键win+shift+s)

## 基于HAL库

自己移植略，我这种懒人肯定不会自己移植的，果断选择cubemx

#### 注意：

1. SYS的DEBUG记得设计成串行Serial Wire(别把system wake-up勾上，不支持)，要不然烧一次之后后面都烧不进去
2. project manager把IDE选择为MDK不然生成的不是keil
3. 烧一次后面烧不进去可以把BOOT0置1，BOOT1置0，keil配置修改一下：进入Debug--Settings--Flash Download页面，把Program、Verify、Reset and Run前面的勾干掉，然后按复位键，再点击下载，下载程序进行芯片的擦除。恢复BOOT0接地。再把刚才修改过的Debug配置改回来，就可以正常使用了。



### 板级支持包

![image-20221226153710749](C:\Users\86180\Desktop\my\note\image-20221226153710749.png)



板级支持包是用户层和底层之间的桥梁，有点像硬软件结合的模块化编程，我们就是搞这个的，准确点说

![image-20221226153914467](C:\Users\86180\Desktop\my\note\image-20221226153914467.png)

（简称BSP，可以让上面的函数调用变的简单，就是个驱动）

建立板级支持包要建立.c和.h文件，并把.c文件放到项目中(core),然后引用.h文件(魔法棒->c/c++->include path->新建并选择含有.h文件的文件夹(不能引用.h文件，根本显示不出.h文件))

以LED的板级支持包的构建为例，这里需要的功能有:初始化GPIO;点亮LED\熄灭LED\翻转LED的状态



stm32的地址使用基地址加上偏移地址来表示，如果还想寄存器编程一样一个一个宏定义出它们的地址属实太sb了，于是就有了这个用一个结构体表示所有地址的优雅方法，从这样![image-20221226173856239](C:\Users\86180\Desktop\my\note\image-20221226173856239.png)

通过宏定义

![image-20221226174042842](C:\Users\86180\Desktop\my\note\image-20221226174042842.png)



![image-20221226174311409](C:\Users\86180\Desktop\my\note\image-20221226174311409.png)

![image-20221226173916671](C:\Users\86180\Desktop\my\note\image-20221226173916671.png)

-----

## 3.29

### HAL库外设驱动概览

1. 句柄结构体(xx_HandleTypeDef):
   1. Instance:指向外设内，一个具体的外设成员。如USART里的USART1，USART2,DMA里的Channel1,Channel2,是一个指向外设基地址的指针
   2. Init:指向了一个**具体外设**的初始化结构体，用来配置外设的工作参数,类型就是初始化结构体
   3. Lcok锁定,State状态等
   4. 各种回调函数
2. 初始化结构体(xx_InitTypeDef):用来配置外设的工作参数 具体的参数配置就是选择题，对后面ref后面的内容find next就能看到备选的选项

### 中断与异常

![image-20221204115733384](C:\Users\86180\Desktop\my\note\image-20221204115733384.png)

中断有优先级，小值优先

​	f103为例，使用了M3内核支持8bit优先级中的高4位bit，所以stm32支持16个优先级，但其实不够，为更好管理，对这4个bit进行分组，分为5个组，每个组分为抢占优先级组和子优先级组(响应优先级组)。

![image-20221204120601851](C:\Users\86180\Desktop\my\note\image-20221204120601851.png)

![image-20221204120729955](C:\Users\86180\Desktop\my\note\image-20221204120729955.png)

IRQ编号在芯片头文件里

#### EXTI

![image-20221204124955130](C:\Users\86180\Desktop\my\note\image-20221204124955130.png)

![image-20221204125102526](C:\Users\86180\Desktop\my\note\image-20221204125102526.png)

![image-20221204125214290](C:\Users\86180\Desktop\my\note\image-20221204125214290.png)

​	边沿检测是检测电平变化的，而上升沿/下降沿触发选择寄存器则是决定该信号是否会往后传递。上升沿就是从高到低(当然是一个周期内)，下降沿自然是从低到高。(所以高低电平触发和边沿触发的区别就是一个靠过程，一个靠结果)

​	边沿检测寄存器是需要线的，即硬件中断事件寄存器。(图中是与门)

​	如果是事件模式，就只会通过下面的线产生事件，通过脉冲发生器发出去；如果是中断模式，就是不走下线最后一个与门(准确来说是事件屏蔽寄存器是0，与门过不去)，只是触发中断；当然还有又有事件又有中断的模式。

​	中断大概流程有：EXTI触发中断，CPU会在中断向量表中寻找对应的偏移，并找到该偏移对应存放的入口地址，这个地址中存放了中断服务函数，随后就会执行该函数并清除掉中断标志。

![image-20230314110146983](C:\Users\86180\Desktop\my\note\image-20230314110146983.png)

这个NVIC界面中要记得先勾选对应的EXTI线的中断，把终端打开，再勾选上面的sort by preemption priority and sub priority来表示用抢占优先级和子优先级来决定中断排序，然后选择左边的选项(但是我的电脑经常显示不全，它的完整版应该是问要用几个位来表示抢占优先级，别搞反了)

### 串口通讯

通信方法:

1. 并行通信：数据各个位同时传输   优点:速度快            缺点:占用引脚资源多
2. 串行通信：数据按位顺序传输       优点:占用引脚资源少    缺点:传输速度慢



串行通信按数据传送方向，分为:

1. 单工：数据传输只支持数据在一个方向上传输
2. 半双工:允许数据在两个方向上传输，但是在某一时刻，只允许数据在一个方向上传输，他实际上是一个切换方向的单工通信
3. 全双工:全双工通信是两个单工通信方式的结合，他要求发送设备和接收设备都有独立的接收和发送能力

串行通信的通讯方式:

1. 同步通信：带时钟同步信号传输    (-SPI,IIC通信接口)
2. 异步通信：不带时钟同步信号的（-UART（通用异步收发器）(一种约定，即协议，如约定波特率，这样就知道多久采集一次数据)，单总线）

![image-20230305005446424](C:\Users\86180\Desktop\my\note\image-20230305005446424.png)

stm32的串口通信接口:UART:通用异步收发器  和   USART：通用同步异步收发器(可以当UART用)

芯片上的txd和rxd要与电脑的DB9连接需要转换器

查串口对应的端口要查硬件资料里的芯片名.pdf(USARTx_TX/RX)

![image-20230305010629601](C:\Users\86180\Desktop\my\note\image-20230305010629601.png)

设置波特率(F1)

![image-20230306230245912](C:\Users\86180\Desktop\my\note\image-20230306230245912.png)



求出USARTDIV，将它的整数部分和小数部分填入寄存器的相应位数

USART使用流程:（根据stm官方注释）

1. 定义一个UART_HandleTypeDef结构体句柄
2. 通过HAL_UART_MspInit函数来实现串口外设的底层初始化:
   1. 使能UART外设时钟
   2. 配置UART的引脚模式
   3. 如果要用中断，就配置中断
   4. 如果要用DMA，就配置DMA
3. 通过前面定义的结构体句柄来配置串口的波特率，数据字长，停止位，奇偶校验位，硬件流控制



### 重定向printf函数

printf会被<studio.h>解析为fputc()函数，由该函数实现最终输出；我们要根据最终输出的硬件重定义fputc()函数，这一过程就成为printf重定向

1. 避免使用半主机模式
2. 实现fputc()函数

半主机模式:通过仿真器来实现开发板在电脑的输入输出			但是我们一般直接用串口连，所以一般不用半主机模式

做法：使用微库法(魔术棒里)；使用代码法(去拷贝一份这代码就可以了)



### DEBUG方法



### DMA:直接存储器访问

![image-20230329154729100](C:\Users\86180\Desktop\my\note\image-20230329154729100.png)

![image-20230329154853872](C:\Users\86180\Desktop\my\note\image-20230329154853872.png)





DMA作为一个外设，不过CPU，也不在APB里，直接接总线矩阵，这样就不用占用CPU还可以搬数据(存储器与存储器或者外设与存储器都可以)(一般搬数据需要CPU疯狂访问SRAM)

![image-20230329155156096](C:\Users\86180\Desktop\my\note\image-20230329155156096.png)



使用需要:

1. 建立(选取)传输通道  存储器-存储器  外设-存储器  存储器-外设
2. 确定传输对象。明确要实现的具体功能，如UART(源)-内存(目标)(串口数据存到内存中)
3. 确定传输细节  
   1. 确定由谁产生DMA请求 (外设的DMA请求对应通道)
   2. 通道优先级问题(通道是串行的) 
   3. 确定传输数据双方的数据格式  
   4. 确定数据是否需要一直采集(循环模式是否使能) 
   5. 是否需要传输标志/中断
   6. 源地址/目标地址是否递增



一般内存就要地址递增(不然一直传到一个内存地址里有啥用)，外设地址一般不递增(寄存器就那一个地址递增想干嘛)

DMA模式中USART_RX是外设->内存，USART_TX是内存->外设

在USART使用时用对应的中断函数（HAL_UARTEx_ReceiveToIdle_DMA）和中断处理处理函数（HAL_UARTEx_RxEventCallback）即可







-----

### 4.22

#### IIC

配置略

#### 基本函数：

1. 写：` HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);`

2. 读：`HAL_I2C_Master_Receive(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout);`

3. 写多个数据：

   ```c
   
   HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout);
   /* 第1个参数为I2C操作句柄
      第2个参数为从机设备地址
      第3个参数为从机寄存器地址
      第4个参数为从机寄存器地址长度
      第5个参数为发送的数据的起始地址
      第6个参数为传输数据的大小
      第7个参数为操作超时时间 　　*/
   ```

4.  

5. 

### 9.30

RTC
