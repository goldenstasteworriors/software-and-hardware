# C语言笔记

##  程序框架

#include<stdio.h>



int main()

{









return 0;

}

----



## 注意事项

1. 一定要用英文输入法
2. 语句结束要加分号，不然后面的东西无法执行
3. 对于我们练习和考试用的傻鸟软件，他只能在运算前声明所有的变量，不能在后面声明
4. 任何括号里的东西对变量的赋值都是要算的，千万别忘了(逻辑运算)

-----



## 基础知识

1. %d代指后面的整数，实际I/O时它会被自动替换为后面的内容,记得用逗号将它与后面内容分开

2. %f （用于输出时）                  浮点数（小数）如果前面printf用了%f,那么()即使前面后面整数和浮点数的运算就会先把整数变成浮点数再运算，结果也是浮点数。（但是输入时要写成%lf）

3. count 常数 如定义常变量就可以是 int count i=100 如此之后该变量就不能改了（不能再把它放在等号左边）

4. 常用的转义序列：

   | 字符表示 | 名称         |
   | -------- | ------------ |
   | \n       | 换行         |
   | \r       | 回车         |
   | \\\      | 反斜杠字符   |
   | \\"      | 双引号字符   |
   | \nnn     | 八进制表示   |
   | \xnn     | 十六进制表示 |

5. 注释：注释是完全给人看以帮助理解代码的，计算机根本不管，所以所有格式都可以不遵守。通常有两种注释方式：

   * //+注释内容 这种方式只能用在一行里，可以不在一行的开始，可以直接接在别的语句后面，但是不能超过一行
   * /*+注释内容+ */ 这种方式想注释几行都可以，两个斜杠星号之间都是注释

6. 数字前后缀

   * 进制：一个以0开始的数字是8进制，以0x开始的数（或数字后加h）是16进制，数字前加b表示该数用2进制表示；%o用于8进制，%x用于16进制（输出是只输出数字，没有0或0x）
   * 数据类型：数字后加U表示无符号整型，加L表示长整型，加F表示浮点型

7. 科学计数法：如-5.67E+16就是-5.67*9+(10^+16)



------



###  变量

定义：<变量类型><变量名称>

注：

1. 变量名称不能是标记符

2. 可以一次性定义多个变量（中间用逗号连接），但如果要赋初始值，最好一个一个弄。如

   int a，b /int a=0; int b=0

   

*****

### 数据类型

 #### 常见数据类型：

* int 整数 他默认整数与整数的商只能是整数，故会自动只管整数（而不是四舍五入）用int时后面不能是浮点数（不能带小数点）（int对应的格式化是%d）

       int 表达的是寄存器的大小（字长相关），所以大小不固定（int表示的是RAM与cpu编译器之间的数据宽；也即总线所能传输的数据大小；int=8字节，一字节=8bit，那么计算机是8*8=64位哦；如果是32位的系统（准确的说应该是cpu），那么int=32/8=4字节.）

* 

* double 双精确度浮点数（可以带小数点）它的意思不是与两个变量有关，只是比float精度更高（有更多小数点） double对应的格式化是%lf（小数）和%e（科学计数法）

* float 单精确度浮点数 对应的格式化为%f（输出小数）和%e(输出科学计数法)

* （浮点数很离谱，它的精度很高，比如你输入一个a=1.1f，但是它可能在计算机里实际认为a=1.1316531613等等（我们改不了它后面的小数）所以浮点数用来计算有误差，很可能两个1.1f不相等，故计算时记得用整型）

* 关于浮点数，可以在%和f之间加上“.x”以让它表达小数点后x位，但是这样会四舍五入

* char 有符号字符字符型 只占一个字节 范围是-128-127，所以如果赋255给一个char，他会变成-1

* 关于char的理解：字符和ascll码中的数字一一对应，字符需要加上''，如果要输入输出字符，格式化对应的是%c（此时输入和输出都不会带''） 。还要注意，其实字符既可以通过''表示，也可以直接用ASCLL码中的数字表示，其实电脑认为这两种表示是一样的（前提是这确实是一个字符类变量），无论怎么输出（赋值）某变量的，都可以通过%c和%d两种方式输出字符和对应数字这两种形态

* 进一步说，在我们目前学习的内容中，char和int是完全等价的，''加上符号和其所对应的ASCLL码是完全等价的，输入输出的是整数还是其ASCLL码对应的符号完全是看格式化用的是%c还是%d

* 关于字符还有一个离谱的点是输入多个数据而后面是字符时一定要记得加空格，不然我们在输入时就不能有空格，否则它就把空格的ASCLL码输入了

   #### 类型转换

   * 自动：
* 强制：（想要转变成的类型）值 如（int）10.2，但是要注意把大的量给了小的类型它很可能表达不了大的量，甚至可能会很离谱（因为它转化的逻辑很直接，就是直接取后面一定位数来读，所以正负颠倒之类的常有发生，所以注意别超过小变量的范围）（强制类型转换只是创造出一个新的变量，不会改变原变量的值）(==最好现在开始，强制类型转换前后都加上括号==)



### 注：

1. 可用sizeof()得到某数据的类型占几个字节，注意sizeof是静态运算符，它只会判断后面的类型而不会执行括号内的操作，如sizeof（a++）后a并没有+1
2. 想要不用补码，全部表达正数，可以用unsigned
3. 可以把数据想象成一个圈，0在下，正数在右，负数在左，0的左边就是-1，加法就是往右走，所以很容易明白正最大值+1之后会得到负的最小值（最大数值加负号）
4. 一般有符号值的正最大数的值比负最大数的值小，因为相当于正数给了一个位置给0



### 其他数据类型

#### 引用

1. 给已定义的变量一个别名（这个变量不用事先定义）

2. 引用后，变量会有一个原名称和一个引用名，不能再把该引用名作为其它变量的引用名

3. 例：int a;

   **int &b=a(声明b是a的引用(b是a的引用名))（别把&放错位置）**

   

指针

1. 用一个变量存另一个变量的地址就把它称作指针。

2. 定义：数据类型 *标识符（* * 叫指针类型说明符）

   如:int *i;

3. 相关算符有：&(取地址)和* 如*i代表i所指向的存储单元

   

   例：

   int a,b;

   int *p1, *p2;

   p1=&a;

   p2=&b;（切记这里p1，p2前不能有*）

   cout<<*p1<<" "<< *p2<<endl;

   即可输出a b

数组

1. 定义：数据类型 数组名[常量] (必须是常量，要用来定义数组大小，不能是变量)

   如：int n[5];

2. 初始化：

   * 把元素列出来：int n[5]={1,2,3,4,5}(如果选择这种方式，则可以和定义一起，而且定义时不用指明元素个数)

   * 一个一个赋值

3. 使用：第一个元素下标为0，以此类推

   

### 算术运算

#### 算符

1. %代表取余,如果两个整数中有负数，则==结果的符号与被除数相同(%要求对象是整型)==

   如：7%5=2;-7%5=-2

2. += *=等复合赋值是指前面的东西+/ *等后面的东西（后面的东西自动加括号，表示要先将后面东西算完后再用前面的东西和后面的东西运算）

3. ++/-- 等递增递减算符 它们既可以放变量前也可以放变量后，都代表一次运算。++无论在前还是在后都会使变量的值+1，但如果在前，该表达式（如++a）代表a+1后的值，故如果要输出++a，则会输出原来的a+1以后的值；在后就代表原来a的值。（推荐前置）

#### 优先级

* 赋值优先级最低，其他按常识判断
* 单目算符优先级最高，如-/+（好像递增递减也算）





### 三目计算符

优先级只高于赋值和逗号，不建议使用（完全可用if else代替），但是最好能读懂

count=(条件)?条件满足时的操作:条件不满足时的操作

如：count=(count>20)?count-10:count+10

### 逗号运算

用处是只取后面的那个结果， 目前只用于for语句中，由于只有三个区域，如果想要执行多个操作或设定多个初始值的时候可用","把操作分隔开



### 关系运算

#### 关系运算符

| 运算符 | 意义       |
| ------ | ---------- |
| ==     | 相等       |
| !=     | 不相等     |
| >      | 大于       |
| <=     | 大于或等于 |
| <      | 小于       |
| <=     | 小于或等于 |

#### 关系运算结果

关系成立则为整数1，不成立则为整数0

#### 运算优先级

* 比较运算比赋值优先级高，比其他运算优先级低
* 判断是否相等的==&!=优先级比其他的低
* 连续运算是从左到右算的
* 与（&&）优先级比或||高，即a||b&&c实际上是a||(b&&c)
* 优先级顺序:非与或

#### 注：

1. 一定要注意它如果不止一个比较运算符时的结果，不要把它看作一个连等或者连续不等式，如：4<6<5 该式结果是正确的，即结果是1，因为从左到右先算4<5，结果是1，再算1<5，结果是0.
2. 单目运算符的方向是自右向左，其他的都是自左向右
3. 不能连等或者连续不等式，要用||，&&等连接

----

### 逻辑语言

| 运算符 | 名称   |
| ------ | ------ |
| !      | 逻辑非 |
| &&     | 逻辑与 |
| \|\|   | 逻辑或 |

注：

1. 如果对则结果是1，错则结果是0.但是对于判定来说只有0是错的，非0就是对的。如：

   int a=2;

   !a=0

2. 逻辑运算并不会都算出结果,而是一旦表达式结果确定，就不会进行余下的计算

3. 逻辑中，与的优先级比或高(非与或)

4. 逻辑运算中的赋值时会影响到外面的(除非被逻辑运算负作用影响没到赋值就出结果了)

-----

### 判断与循环

1. if语句用法：==break不能跳出if语句==

   1. if(.....（一个关系，如a<b）){....(输入一段代码，该代码在前面关系成立时运行，，否则整个大括号跳过)}
   2. if(.....（一个关系，如a<b))........;(一段代码（通常只有一句话，到分号为止)(前面那个关系式括号后不能加分号)（不推荐使用）

2. do while用法

3. while用法：

4. else语句用法（与if连用）：if(){}else{}。//if的大括号后面不能加分号

   或 if(){} else if(){} else(){}     ()多分支语句

5. for语句用法：

​      

5. switch_case用法（用于判断）：switch(控制变量式){

​        case常量//用于告诉你是哪种情况，该常量在程序中无作用//：

​                         语句

​        case常量：

​        语句

​        .......

​        default:

​         语句

​        }

​		switch的作用是选择，它只能用于整型和字符，看switch后给的常量是否与case后的相等，若相等就执行那个case，若都不等就跳到default，然后到结束的大括号就出语句。

如： int a; scanf("%d",a)   switch(a){case 1:.........;break;case 2:.....;break;default:........}

这个语句中我输入1，就到case 1里，输入2就到case 2里。

注：

1. default可以放在几个case的中间，这样如果case都不对就会到中间来，而且此时如果没有break就不会出语句，而是会接着执行下一个case，直到遇到break或者大括号。
2. 如果想在某个case里面定义函数，需要在该"case:"后面加上大括号

3. 一定要记住if后面的圆括号中的其实是个bool，即它只会判断里面的量是不是0，所以不一定要输入关系表达式。***如果是0，就不会执行后面的语句；如果是非0的数，就会执行**

4. 如果switch的是字母，那么case后面的字母应该要加''

5. 如果要在switch中定义变量，那么switch冒号后面要加{}

   



####      循环的选择

* 如果有固定次数，用for
* 如果必须执行一次，用do_while
* 其他情况用while

#####        其他：

* break表示终止（该层）循环，直接出去
* continue表示停止（该层）这一轮循环的剩余步骤，但是下一个循环要继续
* 如果有多重循环，那么要另外设置一个变量，使其改变时达到接力break的效果
* 跳出多重循环的高级方法：goto  即可以在想要跳出的地方加一个“goto out”,然后在想要跳到的地方加一个“out：”（相当于传送门）



####     注：

* case只是路牌，不能挡住程序，要终止程序只能让它碰到break,如果没有，就会继续到下一个case，直到碰到break（当然，我们一般一个case配一个break）

* 分号是要打在语句的大括号里面的，大括号外面不用打分号。

* for最后一个每个循环需要执行的操作后面（即后面的括号前）不用加分号

* for循环如

  for(i=0;i<n;i++){a=b+1;if(!a%10)break/continue;}这种若是break，则就不会再执行i++了，如i=1时break了，那它最终就是i=1;若是i=1时continue，则继续循环后之后不会再重复一遍，而是直接从i=2继续.



## 函数

1. 定义：void 函数名(需要用的参数（需要在这里定义参数）){函数体}（函数体前面那的东西都叫做函数头）

2. 调用：函数名（参数值）  （这些值会按照顺序依次初始化参数） （没有参数也要打上空的圆括号）

3. （C99only）声明：函数头+；（函数原型）

4. 函数返回的值就相当于把函数视为一个算式的结果，如果有返回值就可以直接把函数赋给变量

5. 如果要返回一个值给调用函数的地方，就定义函数时用int然后让它return一个变量出来。如果是只是要输出之类的就不用返回值，就用void值就好了，但不返回值就不能给函数赋值了（定义函数时用的什么数据类型就只能返回什么数据类型）

6. **==emergency==**学后面的类时突然发现我一直以来的一个巨大认识错误：我一直以为函数不借助地址指针除了返回值什么都传不出来，这从某种含义上来说没错，但我因此潜意识地认为函数就不能对外界产生影响，这其实不正确，==函数可以直接改变全局变量的值==而我们要在函数中用指针操作是因为我们大部分时候要改变的是函数中的局部变量，而且是确切的，说的有点懵但是我已经试过了应该能理解什么意思

7. 带有默认参数值的函数：如果实参没有赋值，形参就会被赋默认参数值。==默认形参值必须从右到左顺序声明，要注意带有默认值的参数的右边不能有不带默认值的参数，如`int a(int x,int y=0.int z){}`是错的，而`int a(int x,int y,int z=0){} `是对的==

   ==如果函数只有定义没有声明，则默认值在定义中给出；如果函数又有定义又有声明，则默认值在声明中给出；不能既在定义又在声明中给出默认值，即使是给的一样也不行==

8. 函数重载：函数名相同，但是形参个数，类型，顺序不同(注意，不能以形参名，返回值类型不同来区分),如对int add(int x,double y);

   ```c++
   int add(double x,double y);//正确
   int add(int x,int y,int z);//正确
   int add(double x,int y);//正确
   int add(int a,double b);//错误，不能以形参名不同来区分
   void add(int x,double y);//错误，不能以返回值来区分
   ```

   

9. 内联函数：目的是解决函数调用时的效率问题。内联函数并不在遇到函数时去调用函数，而是直接把函数代码嵌入到每个调用函数的地方（像宏定义）。

   形式:inline 类型 函数名(形参列表)

   内联函数体内不能有循环语句和switch语句，且定义必须在第一次调用它之前给出

10. 参数值的引用传递：

    ```c++
    void swap(int &a,int&b){int t;t=a;a=b;b=t;}
    ```

    这样该函数调用时swap(x,y)参数值的传递就是`int &a=x;int &b=y;`,这样就相当于形参是实参的引用，可以通过操作形参a,b直接操作实参x,y，连指针都不用

11. 当函数要操作数组时，可以用数组或指针作为函数形参,但是都只能传进去首地址，长度传不进去

    ```c++
    void sort(int arr[],int len);//用数组传
    void sort(int *arr,int len);//用指针传
    ```

    随后可以通过经典的arr[i]或*(arr+i)进行操作，一般限制为`for(i=0;i<len;i++)`

12. 函数操作字符串：形参类型为char*，传进去的也是首地址，不过可以通过检测是否为0判断长度，一般限制为`while (*p)`

13. 递归：自己调用自己，关键要做到 1.确定中止条件，终止条件是指在该条件下，函数不用调用自己2. 找到递推关系  如用递推给出阶乘函数

    ```c++
    int f(int n)
    {
    	if(n==0)return 1;
    	else return(n*f(n-1));
    }
    ```

     注意:中止条件要写在函数调用自己前。

14.  



#### 注

1. 函数的定义要在主函数之前（==也可以在主函数之前先声明==）

2. 不要乱加分号

3. 声明时可以不写参数的名字只写参数的类型但是一般都写

4. 声明可以放在主函数第一行，但现在一般都放外面

5. c语言在调用函数时给的值与参数的类型不匹配时，会自动在自动把你给的参数类型换成函数中参数的类型，但是其实很多时候时我们写错了，这是一个漏洞 如函数中

   void cheer(int i){printf("%d",i);}

   int main(){cheer(2.0)}

   这个函数中，编译器会自动把我们的浮点数换成函数中说好的整数而输出2。

6. c语言在调用函数时，永远只能传值给函数，一样的参数名（如a，b）起到的作用只是在调用函数时，把主函数的参数值传给函数中的参数（实际上是把参数传进去而不是把值传进去，不过c语言只能传值进去，所以这么说暂时也没什么问题），而在函数中的参数怎么变化对于主函数没有影响，如交换参数值的函数根本做不出来（这句话忽略，现在学到指针了，能做出来了），因为参数值传不出来，值只能传给函数。每个函数都有其对应的空间，参数在其空间中，与其他函数没有关系

7. 如果函数里面没有参数就在圆括号中加上void

8. 如果在函数中要对数组进行操作，那么在声明参数时也要加上数组，如int a[]

9. (C99only)可以加一大堆大括号用于调试，在大括号内可以有自己的变量，而且可以在定义自己的变量前输出外面变量的值，如int main(){int i=1}{printf("%d",i);int i=2}那么就会输出外面i的值，即1

#### 变量

1. 全局变量在函数外声明，作用域是定义处开始的整个文件；局部变量的作用域是函数内或块内

2. 如果未初始化，全局变量会自动初始化为0，局部变量会变成乱码

3. 一般的局部变量是自动变量(省略掉auto)，他储存在动态存储区，作用域和生存期都是一样的，即函数中或块内

4. 变量名加上static就可以把它变成静态变量，这种变量生存期和作用域不一致:作用域还是和函数挂钩（所以不能在其他函数中引用不在它那定义的静态变量），但是他的生存期是全局变量，所以它的值不会被清除，下次调用这个变量时还会是原来的值(其实从地址来看它是和全局变量放在一起的，就是个挂着本地变量名字的全局变量)

   静态变量的特点可以在下面例子中完美展现：

   ```c++
   void fuc(){(static) int n=4;cout<<n<<endl;;++n;}//()表示是否有static的对比
   void main(){
      func();func();func() }
   ```

   如果有static，结果是4,5,6;如果没有结果是4，4，4。这是因为自动变量在每次调用函数时的地址都不一样，每次都会初始化，而自动变量的地址是不会变的，同一函数的初始化语句都只会执行一次

5. 加上前缀extern就表明这是其它文件中定义的变量，但在本文件中引用

### 基础函数



#### printf

用于输出，格式:

printf（"...."）;用于输入内容，格式：

#### scanf

scanf（"%d\n",&...(某变量)）；（==输入语句会自动换行，一定记得==）

注：

1. 一定要注意该函数读取的是“”中的全部内容，如要是

   scanf<"%d,%d",&a,&b> 则输入a的和b之间必须用，连接，不然读不到。
   
1. 记住引号中的都是要输出/输入的内容，\n就属于这种，而%d对应的函数就不属于

   
   
   
   
   
   
   
   
   ------
   

### 字符串

c语言中所有的字符串都可以看做带结束符的字符数组。

无论字符串还是数组，其实逻辑都是一个从某地址开始读，到'\0'为止，所以如：

char *s="SB";printf("%s",(p+1))   就会输出B

#### 字符串常量

如：char \*s="Hello world"（等价于char *s;s=“Hello world”）

1. 字符串常量其实是编译之前就定义好的，已经放在某地址（和代码放一起）里面的，是一个只读的常量，不可修改数组中的某一个元素。而*s这种都只是指向它的地址，故如果char *s1="1";char *s2="1";就会惊奇的发现s1=s2，他们相等而且是一个很短的地址

2. 如果想要改，就用数组

3. 想要定义一个字符串用指针，想要处理一个字符串用数组

4. 字符串也有对应的输入输出初始化：%s（遇到Tab和空格，Enter都会停止读入）(但是输入的时候最好在%和s之间加入一个数字，告诉程序最多只能读这么多字符，以免输入的多于数组中定好的造成崩溃

   如：char str[6];scanf("%s",str)然后输入123456（有一个结尾的0所以长度超标了），那么就会崩。但是如果用scanf("%6s",str)还是输入123456就只会读12345然后自动在后面补一个0.不仅如此，如果后面还有scanf就会把这个后面的数读掉，如scanf("%6s%6s",str,str2)神奇的事情发生了，输入123456和任何东西，都会让str变成12345然后str2是6）

5. 空字符串：char str[5]=""那么他就是5个0，但是char str[]=""的话该数组长度就只有1了，就只有一个0.

#### 注：  关于字符串/数组的问题：

1. `char*s="abcd"`;和`char*s;s="abcd"`等价这里的""进行了以下操作

   * 申请了空间(在常量区)存放了字符串
   * 在字符串末尾加上'\0'(即NULL,不是'0')
   * 返回首地址地址 

2. 这里的s就是指针的名称。它的含义是字符串第一个元素的指针；但是我们会发现`cout<<s;`结果是abcd这是因为<<存在重载操作，所以如果它检测到你要输出一个字符串地址，它会自动认为这是一个字符串的首地址并直接输出这一字符串，如`cout<<(s+1);`结果是bcd，而`cout<<*(s+1);`结果是b

3. 字符串指针指向的地址可以修改，但是所指向的字符串内容不能修改，如

   ```c++
   s="efgh";//合法，相当于把s改成了这个新字符串的首地址
   *(s+1)='a';//不合法(而且不报错)
   ```

   

4. 所有数组和指针的组合拳的根本原理在于a可以表示对应数组的首地址

5. 用的时候别忘了最后结尾默认是0，所以在定义时要多定义一位，不然程序会崩

#### 字符数组

1. 如果在字符数组后面加上'\0'，那么它可以相当于字符串，如char str1[]="hust"与char str1[]={h,u,s,t,\0}完全等价，但如果没有结束符就不能对它整体做输出

2. 字符数组可以整体输出，如`char a[]="hello world";cout<<a<<endl;`结果是hello world

3. 整体输出字符串的结束条件是自动监测是否为0，但是如`char a[]="hello 0 world"`结果是hello 0 world,但是`hello \0 world`结果是hello ,而`char a[]="hello world"; a[5]=0;cout<<a<<endl;`结果也是hello(在""里的东西都默认是字符，默认加上了'')

4. 它和上面的字符串常量的区别是源于系统将本来写在代码段的只读字符串复制下来粘贴到了数组的地址上

5. 二维字符数组可以按行初始化，也可以按行输出，如

   初始化：char[2] [10]={"wuhan","hust"}(和一般的二维数组一样用"',"连接)

   输出：cout(这里暂且用c++)char[1]（像这样只有一个中括号系统会自动认为你是按行输出，故会把你中括号中的数当作行数） 结果(若按照上面初始化)：wuhan

6. 

### 字符串数组

1. 二维数组，如char a[] [10]={"Hello","SB"}
2. 正经字符串数组:char *a["Hello","SB"];    a[]中每个元素都是一个指向字符串的指针，可以用a[i]这种遍历

#### 字符串函数

(按道理来说下面函数括号里都应该是指针，但是数组可以直接当指针使用，所以没问题)

1. strlen:strlen函数返回的是在字符串中’\0’前面出现的字符的个数,如：

   char str1[]="wuhan" ；int a=strlen(str1)；printf("%d",a)，该程序会输出5

2. strcpy:strcpy(char destination,char source)

   strcpy是覆盖拷贝，将source全覆盖拷贝到destination，会把’\0’也拷过去，且必须考虑destination的空间够不够
   (==destination的空间必须>=source的空间==)，如：

   ​	char str1[]="Hello there";
   ​	char str2[]="SB";
   ​	strcpy(str1,str2);
   ​	cout<<str1<<endl<<str2<<endl;

   结果输出为SB 换行 SB

3. strcat:strcat追加拷贝,追加到**目标空间后面**，==目标空间必须足够大==，能容纳下源字符串的内容(其实也就是连接),如：

   char p1[20] = "hello"; const char* p2 = " world"; strcat(p1, p2); printf("%s\n",p1);

4. strcmp:比较两个字符串的大小，一个字符一个字符比较，按ASCLL码比较
   标准规定：
   第一个字符串大于第二个字符串，则返回大于0的数字
   第一个字符串等于第二个字符串，则返回0
   第一个字符串小于第二个字符串，则返回小于0的数字

   (所谓一个一个比较是指从左到右比较，若两个字符串中有某个字符不相等，那么这两个字符比较的结果就是字符串的比较结果)(其实准确来说，该函数的返回值是那个不一样的字符的ASCLL码的差值（第一个减第二个）)如：

   char* p1 = "abcdef";
   	char* p2 = "abcdef";
   	char* p3 = "abcd";
   	char* p4 = "bcde";
   	printf("%d\n", strcmp(p1,p2 ));
   	printf("%d\n", strcmp(p1,p3 ));
   	printf("%d\n", strcmp(p3,p4 ));
   结果为0,1，-1

5.  strupr:将字符转换为大写； strlwr:将字符转换为小写（即时生效，用了之后后面的数组都改变了，不用专门放一个数组去接）

6. str



#### ==番外篇：cin,cin.get,cin.getline,getline之间的战斗==

1. cin:遇到结束符（Enter,Tab,）就结束读取，结束符仍保留在缓冲区，但是由于cin根本不读结束符，所以如果一直用cin就没什么问题，但如果后面又用别的，那后面的很可能会把这些还在缓冲区的结束符读进去，如

   ```c++
   char ch1,ch2[3],ch3;
   cin.get(ch2,3);
   cin>>ch1;
   cin.get(ch3);
   ```

   输入如下：sb（Enter） 2

   就会把sb赋值给ch2，2赋值给ch1，把Enter赋值给ch3（只会请求键盘输入两次，如果缓冲区有东西就会直接把缓冲区的东西读入，不用再输入）

2.  (要读空格用这个)cin.get(字符数组名，接收长度，结束符（默认Enter可选Tab和Space，选用其他后Enter依然可以作为结束符）)，这东西是会读字符的，空格换行都会读，但是它遇到空格不会结束只会把它当成一个字符读进去，但是遇到Enter会停，但是不会马上读Enter,只是会把Enter放在缓冲区，下次如果再读就会把缓冲区里的Enter读掉，使用时注意：

   * 接收长度是把0算进去的，所以实际上能接收的要-1
   * 虽然这里要的是字符数组名，但是字符变量可以当做只有一个值没有0的数组直接用

3.  cin.getline(字符数组名，接收长度，结束符)和上面的用法几乎一模一样，只是如果超过接收长度的限制就会直接崩而不是只读到这一位其他的放在缓冲区

4. getline是对string类型操作的函数，这里先不讨论

不想要缓冲区里的东西可以用cin.sycn()清除缓存，或者用cin.get()读掉不想要的而不赋值（类似于Serial.read()原理）





#### 注

1. 0和'\0'和NULL是一样的，和'0'是不一样的
2. 可以在printf("")中用两个""""表示一个字符串，如果两个""之间没有别的东西就会自动连接（为了避免过宽）





## 数组

1. 定义： 数据类型+变量名[数组中元素的数量]

2. 数组的集成初始化 

   1. 如果赋值每一个元素，可以不用在中括号中输入元素数量，你在后面写了几个值就会自动认定有这么多元素 如：int a[] ={1,2,3,1,2,4,5};

   2. 如果给的元素数量大于实际输入的数字，那么后面的会自动全部赋值为0（用于只用赋值前面几个元素的情况）
   3. （C99only）赋值其中的几个元素，如：int[5]={[3]=2}(其他的就赋值为0)
   4. 混用：如int a[]={1,2,[4]=6}(这个的意思是前两个是1和2，第四个是6，由于没给元素总数，所以程序会自动认为我们给出的下标最大的就是元素的数量，在这里就是会认为一共4个元素)
   5. 绝杀：将数组定义在主函数外面（记得声明元素数量）就会自动把所有元素都赋值为0

3. 数组中元素的使用：变量名[元素数量-1]

4. 遍历数组：intt number[n]   for（i=0;i<n;i++）if(number[i]...)（会对数组中的每个元素进行操作）（一定要记得从0开始，最后是**小于**数组的长度）

5. 数组是一种容器，其中所有元素具有相同的数据类型，数组数量一旦定义就不能改变

6. []里面的东西叫索引或者下标

7. 可以直接用sizeof得知数组的字节，所以可以运用这一点得到数组的大小：length=sizeof a[]/sizeof a[1]   这个式子无论我们怎么增减数组的元素都可以用

8. 鉴于我目前的理解，数组的优点在于分组，把这些变量都分组之后遍历他们会很简单，由此会引申出一系列的作用，如判断，排除

   #### 二维数组

   1. 定义：行数+列数

      如int a[行数] [列数]={

      {1,1,2,3,0，}

      {2,6,5,8,9，}}（注意要两个大括号，里面外面都要有（也可以在里面不加大括号））

      ==二维数组初始化中列数必须给出，行数可以由编译器来数==，而给出列数行数却没给这么多数就会自动补零

   2. 特例:`int a[][3]={1,2,3,4,5};`则会自动认为是a[2]\[3],而第二行没有满，自动补0
   
   3. 遍历：for(i=0;i<行数；i++){for(j=0;j<列数；j++){printf a[i] [j]}}
   
   4. 二维数组的本质就是一维数组，a[i]\[j]与a[i*列数+j*行数]本质上一模一样









#### 数组的运用

1. 排除：由于没学过排除语句，我们可以用数组简单写一个 例：素数表
2. 









#### 注：

1. 数组中的第一个元素是变量名[0]，最后一个数是变量名] [元素总数-1]

2. C99前元素数量不能是变量，除非用new

3. 必须保证下标不能越界[0，n-1]，因为编译器很可能连警告都不会给，到时候程序错在哪都不知道

4. 定义数组的大括号要接分号

5. 如果想要把一个数组的全部元素赋值给另一个数组，我们不能直接把数组赋值，如a[]=b[]就是错误的，正确的方法是遍历数组，把每个值分别赋过去，如：for(i=0;i<length;i++){b[i]=a[i];}

6. 数组作为函数参数时，要用另外一个参数传入数组的大小，不能用sizeof在函数里面算

7. 可以在定义数组时在后面留下一个逗号，这不会造成什么影响，还能方便后面加元素

8. 数组类型的名字不能和变量名字一样

9. 二维数组中各个数组（各行）之间是用,而不是用;连接的

10. 二维数组行和列都是从0开始

   













## 指针

1. 指针就是保存地址的变量，而地址值占据4byte,32位的空间，对应的数据是unsigned long int型
2. 指针的类型是它所指向变量的类型，用于指明指针一次能访问的空间的大小
3. 定义指针变量前要加上一个*号（在定义时，加上 *只是说明它是个指针变量，所以它并不代表它这个地址对应的变量，所以在函数中如果选择在函数头定义该指针变量效果是这样的：`void hanshu( *pa)      int main(){hanshu(&a)} `因为前面声明函数时的代表的是a的地址，所以后面引用函数时给的参数也是a的地址） 
4. *是一个单目运算符，用来访问（取得）指针所表示的地址上的变量
5. &是一个运算符，它的作用是取出某个变量的地址，所以运算的对象只能是一个变量，如果想要输出这个地址要用%p，如printf("%p",&a)（此处这个&可以省略）（如果直接用int输出也有可能和这么输出结果一样，但这取决于我们的编译器）
6. 数组的指针就是第一个元素的，如a的地址就是a[0]的地址
7. 相邻元素的地址差4
8. 指针的炸裂之处在于它可以让我们在函数里面改外面的东西，想要对外面的参数指手画脚就只能用指针
9. 指针可以作为参数进去，但是作用是返回函数的结果（需要返回超过两个结果或函数返回状态，指针不返回结果（该情况用于函数可能会出错，这是就需要状态量来告诉你错了没有））
10. *加上指针变量就相当于访问改地址对应的东西
11. 指针其实是一个独立的数据类型，所以要用数字给指针赋值要加上强制类型转换(指针类型*)
12. 指针和数组的关系
13. 指针克隆（指针的引用）`int a;int *p=&a;int*p1(p)`就是把p的地址克隆给了p1,相当于p1是p的一个别名

#### 注

1. 指针的初始化是`p=&a*`这种，不是直接`*p=1`这种写法是错的，都没初始化怎么访问这个地址呢
2. *p++的意思是\*(p++)

### 动态内存分配

在C99之前没办法把数组的大小定为变量，因此我们需要动态内存分配

1. 要#include<stdlib.h>

2. 使用如下：如果要定义一个大小是number的数组a，需要

   ```c#
   int a;
   
   a=(int *a)malloc(number *sizeof(int));
   
   free(a);
   ```

   后面所有的使用都等同于定义了一个a[]

3. 以上的意思大概是向系统要了一块空间，大小是number*sizeof(int);但是malloc的返回值是void *,即系统只是给了你一块空间，并不知道你要拿来干嘛，我们需要强制类型转换(int *a)，告诉系统我们打算那这块空间干什么，这里就是要用它来放int

4. free的东西必须是系统给你的空间，如果不是申请来的就会报错。但由于我们会有初始化指针为0的情况，所以可以free(NULL)

5. free只能用于申请的首地址，变动之后都free不了







### 注

1. 指针在指向变量前不能做赋值
2. 函数参数表中的数组就是指针
3.  定义一个指针，就可以直接拿指针的名字当数组用，且*s=s[0;] *(s+1)=s[1]
4.  

#### c++中的动态内存分配

1. 申请内存：指针变量名= new 类型名 （初始化式）`int *p;p=new int(5);`（分配一个空间，空间大小由变量类型决定，将初始化式填到该空间中，并返回该空间的首地址给指针）(初始化式及其括号可以省略)
2. 释放内存：delete 指针`delete p`
3. 动态数组分配：指针名=new 类型名[下标表达式]`int n;cin>>n;int *a;a=new int[n];`
4. 动态数组的访问:用a[i]或*(a+i)都可以`for(int i=0;i<5;i++)cin>>a[i];`
5. 动态数组的撤销：delete[] 数组名`delete[] a;`
6. 



#### 注

1. delete的对象一定是new的返回值
2. delete之后再*p得到的结果就不会是原来的了，而是一串乱码
3. delete只是释放了指针对应的内存，指针本身依然存在，可以指向别的地址
4. 动态内存再内存分配时不能初始化
5. 撤销动态数组时[]中不用写数组长度，写了也会被系统忽略
6. 如果撤销动态数组时没有写[]，系统就会只回收首地址，造成回收不完全
7. 这样的数组没有名字，需要用首地址访问


### 结构

#### 枚举

* 枚举事实上是创造一种数据类型，但是实际上枚举不是很好用，我们一般用它是为了用后面的变量而不是用这种数据类型
* 用枚举主要是为了定义符号量，如用枚举定义一堆的常数就不用一个一个敲
* 在现在的c语言编译器中基本都默认枚举也是用int型了，用int的输入输出方式都没问题



1. 定义
   1. enum 数据类型{变量名1，变量名2......}（默认从0一直往后排）
   2. enum 数据类型{变量名1=a，变量名2=b}(可以不从0开始也可以不连续排)
2. 要用这种数据类型时不能直接用数据类型，要把enum加上

#### 结构

1. 最好把结构声明放在所有函数外，这样在所有函数中都可以使用这种结构

2. 声明：（下面的point是结构类型，x和y是结构变量）

   1. struct point{int x;int};(后面要使用这些结构变量需要用struct point p1,p2;)  (c++中可以直接point p1)
   2. struct{int x;int y;}p1,p2;(只定义了两个结构变量，没有定义结构类型)
   3. struct point{int x;int y;}p1,p2;

3. 初始化：如struct date{int date;int month;int year};那么

   1. 可以用数组一样的定义，如：`struct date today={07,31,2014}`就是把07,30,2014分别赋给了date month year
   2. 也可以只赋值其中几个量，如`struct date thismonth={.month=7;.year=2022}`而这里没有被赋值的day就会被自动赋0(这里似乎c++用不了)

4. 结构用“.”+名字访问其成员，如tody.day

5. 结构运算：要访问整个结构可以直接用结构变量的名字，如p1=（struct point）{1,5}；

   p1=p2

6. 结构与函数：

   1. scanf不能直接读入一个结构，而是要一个一个成员读入

   2. 函数的变量可以是一个结构，使用函数时变量就直接写结构就好了

   3. 要把结构经过函数处理之后的值传出来的方法大致有两种：

      1.  创建一个临时的结构变量，直接把函数类型定义为结构，如:![QQ图片20221012171756](C:\Users\86180\Desktop\my\note\QQ图片20221012171756.png)

      2. 可以直接用简化方法用指针修改(注意->的使用，这玩意用的非常多，用法就是定义一个指向对象的指针p，然后就可以就直接用p->n(成员)达到(*p).n的效果)

         ![QQ图片20221012172231](C:\Users\86180\Desktop\my\note\QQ图片20221012172231.png)

7. 结构中的结构

   1. 结构中的数组struct time testtime[5]{{11,59,59},{12,0,0}{23,5,5}.{5.3.2.}};
   2. 结构中的成员可以是一个结构

8. 

##### 注

1. 声明结构是一种语句，所以别忘了加上“；”
2. 只赋值给部分量时相当于要访问其中的成员，所以别忘了“.”（而且取成员优先级高于取地址，可以写成&today.day）
3. 给结构变量赋值实际上是在做强制类型转换，所以别忘记了圆括号+结构类型
4. 结构变量的名字并不是它的地址，需要用&取它的地址
5. 经常会看到形似`typedef struct a{}c,*b`的定义，其意思是c和*b是struct a的别名,所以b就是一个指向c类型的指针

### typedef

1. typedef用来声明一个已有数据类型的新名字，如:typedef int Length,意思是以后所有的int都可以用Length表示了

2. typedef所起的新名字只能是一个单词且放在最后，在typedef和最后一个单词之间的所有东西都是要用新名字代替的老名字，因为用typedef后这个新名字可以直接用，不用像之前的数组一样在前面写一个struct，后面都用新名字了

3. typeof结构时要把结构写完整，如`typedef struct point{int x;int y}POINT`;

   所以这就引申出定义的新写法，即如：`typedef struct{int month;int day;int year;}Date;`    至于这个结构本来叫什么根本都不用写

4. typedef的另一个好处是大量声明指针的时候可以`typedef char* abc;abc a,;`这样可以创造出a指针，比起写很多*相对简单一点

5. `typedef {int x;int y;}*abc;`这样abc就是个指针(不推荐这么写，后面的兄弟看到abc不会想到这是个指针)

### 联合 

1. union和struct几乎一样，但是struct中各个成员是分开的，没有关系，而union中成员是存在一起的。一般用来读取一个数据的各个字节
2. 



-----

#### 关于文件的简单操作

1. 文件相关操作其实就是面对对象编程，ifstream和ofstream是类的名称，open()是其中的函数，而且是重载函数，可以接一个参也可以接两个参，close()也是
2. open第二个参数可以是app也可以是ate，目前只要求掌握app，意思是叠加，如果文件不存在就创建文件，文件存在就在后面加
3. 如果想要两次叠加需要open(路径,ios::app|ios::out)
4. .eof()作用是测试程序是否结束，如果结束，返回非0值；如果未结束，返回0,。所以一般用法是 if(文件名.eof()!=0) break（用于程序中）或者while(文件名.eof()){} （用于程序开头）

##### 注：

1. 可能不用#Include< iostream>只用#include< fstream>
2. 如果ifstream和ofstream打开的是一个文件，就需要关两次
3. 

-------

## I/O

我们的键盘（输入设备）和程序之间还有一个shell，负责进行简单的行编译，如使\后面的东西逃逸（不执行他们的功能而是视为单纯的符号）。在我们输入结束符（默认是Enter）前我们所有的数据都在shell中，只有输入结束符shell才会把所有的东西输给程序（包括结束符）并会自动在最后加上'\0'(下次输入到时就会把0删掉并从这里开始)。

输入ctrl+D可以让shell传个-1进程序，输入ctrl+D可以直接让程序关掉。

---

### 程序结构

1. 全局变量没有初始化会得到0值(指针得到NULL)，只能用编译时已知的值来初始化全局变量，全局变量的初始化发生在main函数的值
2. 输出时用__ func __(没有空格)就会自动将函数名填入
3. 不要让全局变量之间相互联系(初始化的时候)
4. 变量名加上static就可以把它变成静态变量，这种变量生存期和作用域不一致:作用域还是和函数挂钩，但是他的生存期是全局变量，所以它的值不会被清除，下次调用这个变量时还会是原来的值(其实从地址来看它是和全局变量放在一起的，就是个挂着本地变量名字的全局变量)
5. 在本地变量的作用域外返回它的地址再看这个地址的值，可能它还是原来的值，但这其实是有问题的，栈顶其实已经降下来了，这个地址是可以被分配给其他东西的，所以它的值可能是原来的，也可能不是
6. 变量前加上extern前缀

#### 宏

1. 预处理都是#开头的，它的执行是在编译前的
2. 宏定义：#define 宏名字 要替换为的东西(注意不要再最后加分号) 
3. 宏定义可以不带值，如#difine DEBUG
4. 宏定义可以带参数，如#define cube(x) ((x)\*(x)*(x)

##### 注：

1. 宏定义在第一个单词之后都会被识别为要替换为的东西，无论是括号还是什么
2. 如果包含多个语句，太长了要换行可以第一行第一个语句先用;\结尾，然后在第二行再继续加东西(第二行别用分号结尾啊)
3. 宏的另一个运用是做条件编译时#define _DEBUG这种定义没有值的宏，这样编译器检查时会知道哪些语句要编译
4. c中有一些预定义的宏，他们都是“有翅膀的”，前后都有两个下划线，如\__func\_\_系统会替换为当前函数名(C99)，\_\_DATE__系统会替换为当前日期,_\__FILE\_\_系统会替换为当前文件名，\_\_TIME__系统会替换为当前时间，\_\_LINE\_\_系统会替换为当前行号
5. 带参数的宏其实就是代换之后把值带进去，为了避免错误要注意把参数全部加上括号
6. 带参数的宏很好但又很危险，这都是因为它的参数没有数据类型
7. 



-----

### 奇怪错误原因

1. c语言古老传统，如果没看见声明，会自动猜所有的数据类型都是int

-----

## 对我来说要重点检查程序的哪里

1. 涉及多个变量时变量是否用混，特别是两个单字母变量特别容易手瓢，而且系统不会警告
2. 输入时是否有&符号（我已经漏了好多次了）
3.  判断条件是==不是=
4.  n/=10不是n/10,我总是循环继续条件是n>0所以根本没有结果
5.  
6.  
7.  
8.  
9.  
10.  
11.  
12.  
13.  

----

## 其他（但不是这么重要）

1. 科学计数法中如果是0.1就是1e-1，不能写作10e-1
2. 如果想控制随机数等数字的的范围是0到x，我们可以把它%（x+1）
3. 文件声明的名字.eof（）相当于一个判断，如果文件结束，它的值为1，否则为0
4. 文件输入输出不需要 文件名.fin>>或文件名.fout<<,只需要文件名>>就可以表示(从文件)输入(到程序)，只需要文件名<<就可以表示(从程序)输出(到文件)

## 考试

* 标识符由字母数字和下划线组成，不提倡下划线开头（系统标识符是下划线开头），不能数字开头
* 记住逻辑语句中如果能判断出结果后面的就不会运行了，++和--都没用
* 一种神奇的1表达:int x=2;cout<<x-=2,会输出0（是错的，要加括号）
* 三元运算符:a=条件式?b:c，意思是若满足条件式则a=b,否则a=c
* break和continue都是无条件跳转语句，但是continue只能用于循环，break还可以用在switch
* 00开头表示8进制表示的ASCLL码，0x开头表示16进制的
*  从微机到U盘叫拷贝
*  软件系统包括系统软件和应用软件
*  软盘是一种已经被淘汰的存储设备，不仅空间小(仅MB级)，而且读取速度慢，可以说是
*  ASCLL码的0-32和127都是控制字符，前面包括空格，回车，最后的是backspace
*  微机性能与CPU有关，主板只是支撑作用
*  Cache就是高速缓存
*  字是机器字长，计算机是多少位的，一个字就是多少位                                                    
*  运算器的主要功能是进行逻辑运算和算术运算
*  电子计算机的原理可概括为存储程序和程序控制
*  计算机最早的应用领域是科学计算
*  “裸机”指的是未安装任何软件的计算机
*  浮点数的表示一般包括（顺序也是对的）：阶码符号位+阶码+尾数符号位+尾数（注意，在转换前要首先进行规格化，即转换成一个纯小数与2的E次方之积，且小数点后第一位是1）（记得用补码表示）
*  计算机三大核心设备：CPU，内存储器和输入\输出设备
*  RAM和ROM其实就是两种内存，各有用处，主要区别是RAM断电数据丢失，ROM不会，且ROM一般是只读的
*  RAM又分为动态的和静态的，动态的要不断刷新
*  外存储器也属于I\O设备
*  解释程序是边解释边执行，编译程序是全部编译完直接执行生成的可执行文件







## 其他需要注意的点

1. 避免magic number。即使我们知道我们某个数的意思，别人会很懵逼。所以除了0,1等程序套路中出现的数，其它数如数组大小等最好在程序开头给它定义为常量，后面都用别人看得懂意思的变量名如length等代替这个数，不要嫌麻烦。

1. 出现“烫烫烫”说明数组最后没给末尾的'0'留位置

   
