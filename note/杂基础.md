# 杂基础

### 串口硬件流控制：

串口发的太快接收者处理不过来就只能丢掉信号，很显然这是不能接受的，因此引入硬件流控制(流控)来解决这一情况。用法很简单：开启流控就会多一根线，接收方置零意味着可以接收，否则不行。(CTS发送方，RTS接收方)



### GPIO复用：

很多GPIO引脚和内置外设共用引脚，如果要使用内置外设，就需要配置为复用模式(`GPIO_Mode_AF_OD(PP)`)



## 32启动文件与简单汇编

![image-20231114174403528](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20231114174403528.png)

## 堆栈

栈是由于CPU要临时放东西但是寄存器又太贵而从内存中划出来的一片区域(内存中另一块区域叫做堆)。

### 压栈

![image-20221127003039156](C:\Users\86180\Desktop\my\note\image-20221127003039156.png)

压栈的操作类似于把子弹装进弹夹里面，严格遵守先入后出的原则。栈底是固定的，本来栈底和栈顶是重合的，没进行压栈操作，数据就把栈顶往上(低地址)顶。

### 出栈

CPU找个寄存器把栈顶的数据复制，然后把栈顶往下一格，这个操作叫做压栈。此时原栈顶的数据还在原地没变，但已经被当做垃圾处理了



基本运用有函数调用，因为记录函数返回位置这事完全遵循先进后出，和堆栈简直不要太配。



## API

系统为了自身的安全性和调用方便性提供的可以根据需求提供反馈的端口，通常是一个函数，故也被称为API函数，但也可以以网址等形式存在



## 句柄和指针

指针:一般是在栈(CPU上的，很少的)指上的，可以指向堆(内存里的，基本上要多少有多少)。(所以说最刚开始发明指针应该不是为了什么花里胡哨的功能，只是为了解决CPU内存太少的问题)(所以之前说的低地址指的就是栈，高地址是堆)

句柄是系统的概念，是对底层硬件实例的指针的引用

如果用户每个进程都在内核层创建一个对象来控制硬件，这太浪费空间资源了，所以每个硬件对象在内核层只有一个真实的硬件实例，句柄就是指向这些硬件实例的指针的引用

![image-20230308193642579](C:\Users\86180\Desktop\my\note\image-20230308193642579.png)

容易与之混淆的是spring,它是对象管理机制，基本作用就是为了放止到处new对象导致生成各种垃圾碎片



## JSON

文本数据格式，规范，表达树形结构数据(表格) 可读性强

支持六种类型：

四种常规类型:(不允许内嵌其他值)

1. 字符串：包含在双引号内:`"test string"`;包含双引号用\转义`"test\" string`
2. 数字：可以是整数也可以是浮点数
3. 布尔值
4. 空值

一个JSON文本可以仅含有一个字符串或一个数字`"test string"`



两种允许内嵌的值类型：

1. 对象，建/值对字典(哈希表)：
   1. 包含在一对{}之内:`{"key 2":"value 2"}`
   2. 用  ,  隔开多个键值对且最后一个后不能添加  ,:`{"key 1":"value 1","key 2":"value 2"}`\
   3. 键值对的键必须为字符串
   4. 键值对的值可以是六种值类型的任意一种且无需同一类型:`{"key 1":"value 1","key":""true}`
2. 数组：
   1. 包含在一对[]之中
   2. 用“，”隔开多个值且最后一个值不能添加
   3. 值可以是六种值中任意一种且无统一类型:`["list 1",true,123]`

通过这两个可内嵌的类型，JSON可以轻松套娃实现树形结构的数据：

![image-20240317214240348](C:\Users\asus\OneDrive\桌面\NEW_MY\pictrue\image-20240317214240348.png)

JSON的空格和换行不会造成实际影响